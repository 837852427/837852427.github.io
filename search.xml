<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[....]]></title>
    <url>%2Funcategorized53%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;bits/stdc++.h&gt;using namespace std;int st[200005],p,l[200005],r[200005],ll[200005],rr[200005],pos,ans,js[200005];struct tree&#123; long long l,r,sum,f;&#125;t[400005];struct node&#123; int s,id;&#125;a[100005];void build(int p,int l,int r)&#123; t[p].l=l; t[p].r=r; t[p].sum=t[p].f=0; if(t[p].l==t[p].r) return; int mid=(t[p].l+t[p].r)&gt;&gt;1; build(p&lt;&lt;1,l,mid); build(p&lt;&lt;1|1,mid+1,r);&#125;void lazy(int p)&#123; if(t[p].f) &#123; t[p&lt;&lt;1].f+=t[p].f; t[p&lt;&lt;1|1].f+=t[p].f; t[p&lt;&lt;1].sum+=(t[p&lt;&lt;1].r-t[p&lt;&lt;1].l+1)*t[p].f; t[p&lt;&lt;1|1].sum+=(t[p&lt;&lt;1|1].r-t[p&lt;&lt;1|1].l+1)*t[p].f; t[p].f=0; &#125;&#125;void change(int p,int x,int y,int z)&#123; if(x&lt;=t[p].l&amp;&amp;y&gt;=t[p].r) &#123; t[p].sum+=(t[p].r-t[p].l+1)*z; t[p].f+=z; return; &#125; lazy(p); int mid=(t[p].l+t[p].r)&gt;&gt;1; if(x&lt;=mid) change(p&lt;&lt;1,x,y,z); if(y&gt;mid) change(p&lt;&lt;1|1,x,y,z); t[p].sum=t[p&lt;&lt;1].sum+t[p&lt;&lt;1|1].sum;&#125;long long gs(int p,int x,int y)&#123; if(x&lt;=t[p].l&amp;&amp;y&gt;=t[p].r) return t[p].sum; lazy(p); int mid=(t[p].l+t[p].r)&gt;&gt;1; long long ans=0; if(x&lt;=mid) ans+=gs(p&lt;&lt;1,x,y); if(y&gt;mid) ans+=gs(p&lt;&lt;1|1,x,y); return ans;&#125;bool cmp(node a,node b)&#123; return a.s&lt;b.s;&#125;int main()&#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i].s),a[i].id=i; for(int i=1;i&lt;=n;i++) &#123; while(p&amp;&amp;a[st[p]].s&gt;=a[i].s) p--; l[i]=p?st[p]:0; st[++p]=i; &#125; p=0; for(int i=n;i;i--) &#123; while(p&amp;&amp;a[st[p]].s&gt;=a[i].s) p--; r[i]=p?st[p]:n+1; st[++p]=i; &#125; p=0; build(1,1,100001); sort(a+1,a+1+n,cmp); for(int i=1;i&lt;=n;i++) &#123; if(a[i].s-(gs(1,l[a[i].id]+1,r[a[i].id]-1)/(r[a[i].id]-(l[a[i].id]+1)))&gt;=1) &#123; ans+=a[i].s-(gs(1,l[a[i].id]+1,r[a[i].id]-1)/(r[a[i].id]-(l[a[i].id]+1))); ll[++pos]=l[a[i].id]+1; rr[pos]=r[a[i].id]-1; js[pos]=a[i].s-(gs(1,l[a[i].id]+1,r[a[i].id]-1)/(r[a[i].id]-(l[a[i].id]+1))); change(1,l[a[i].id]+1,r[a[i].id]-1,a[i].s-(gs(1,l[a[i].id]+1,r[a[i].id]-1)/(r[a[i].id]-(l[a[i].id]+1)))); &#125; &#125; printf("%d\n",ans); for(int i=1;i&lt;=pos;i++) for(int j=1;j&lt;=js[i];j++) printf("%d %d\n",ll[i],rr[i]);&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[HDU 1455 Sticks]]></title>
    <url>%2Funcategorized52%2F</url>
    <content type="text"><![CDATA[过于经典的深搜题目，而且难度还不算低…..思路上需要知道多少的长度可以构成合法的长度需要从[最大的长度,所有的长度之和]之间并且这个长度能够使所有长度之和的一个约数所以我们这么枚举即可从小到大。然后到了关键的地方怎么dfs呢，这里要放一个三元组一个表示当前的位置，一个表示当前拼成的合法的个数一个表示当前的一个合法长度的长这里需要排序降序排序这样枚举好枚举也是一个降低复杂度的方法…需要判断一下如果合法的长度满足我们的要求的话就返回即可。这里用的条件判断的dfs，实际上也可以自己设置变量这里就是减少了代码量.如果我们当前的长度满足了单个的要求那么从第一个开始继续搜索同时合法长度加一搜索的时候也要记录bk免得一个木棒用了好几次剪枝一个是如果当前第一个就不满足情况直接返回即可一个就是如果后面跟第一个失败的一样的长度直接过总的来说剪枝第一是排序这样找的时候好找，第二是如果当前就不满足条件直接跳出，第三如果相同就直接遍历 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;int bk[10005],a[100005],now,l,n,sum;bool cmp(int a,int b)&#123; return a&gt;b;&#125;int dfs(int p,int cnt,int len)//p当前的位置,cnt当前拼出来了几根木条了,len表示当前拼接的木条的长度&#123; if(cnt==now) return 1; if(len==l) return dfs(1,cnt+1,0); for(int i=p;i&lt;=n;i++) if(!bk[i]&amp;&amp;len+a[i]&lt;=l) &#123; bk[i]=1; if(dfs(i+1,cnt,len+a[i])) return 1; bk[i]=0; if(len==0) return 0; while(i&lt;n&amp;&amp;a[i+1]==a[i]) i++; &#125; return 0;&#125;int main()&#123; while(~scanf("%d",&amp;n)&amp;&amp;n) &#123; sum=0; for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); sum+=a[i]; &#125; sort(a+1,a+1+n,cmp); for(int i=a[1];i&lt;=sum;i++) if(sum%i==0) &#123; now=sum/i; l=i; memset(bk,0,sizeof(bk)); if(dfs(1,0,0)) &#123; printf("%d\n",i); break; &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 1176 免费馅饼]]></title>
    <url>%2Funcategorized51%2F</url>
    <content type="text"><![CDATA[很好的DP题，本质上是数字三角形的变形从5第一层到4 5 6第二层这样可以把可到达的位置分层然后套用数字三角形即可 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;long long bk[100005][20],f[100005][20];long long n,m,ans,x,y;int main()&#123; while(~scanf("%lld",&amp;n)) &#123; if(n==0) break; m=0,ans=0; memset(bk,0,sizeof(bk)); memset(f,0,sizeof(f)); for(int i=1;i&lt;=n;i++) &#123; scanf("%lld%lld",&amp;x,&amp;y); bk[y][x]++; m=max(m,y); &#125; for(int j=0;j&lt;=10;j++) f[m][j]=bk[m][j]; for(int i=m;i;i--) for(int j=0;j&lt;=10;j++) f[i-1][j]=max(f[i][j-1],max(f[i][j],f[i][j+1]))+bk[i-1][j]; printf("%lld\n",f[0][5]); &#125;&#125;]]></content>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P1017 进制转换]]></title>
    <url>%2Funcategorized50%2F</url>
    <content type="text"><![CDATA[负进制转换结论题，如果出现负数的余数那么设n m r为转换数进制和余数 那么 r-=m,n+=m就行了其他都一样 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;void change(int n,int m)&#123; if(n==0) return; int r=n%m; if(r&lt;0) r-=m,n+=m; change(n/m,m); char c; if(r&gt;=10) c=r-10+'A'; else c=r+'0'; printf("%c",c);&#125;int main()&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); printf("%d=",n); change(n,m); printf("(base%d)",m);&#125;]]></content>
      <tags>
        <tag>结论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵快速幂模板]]></title>
    <url>%2Funcategorized49%2F</url>
    <content type="text"><![CDATA[解决大斐波那契数问题，我线代没学所以不是很理解这玩意，只好先记住以下板子了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;struct node&#123; long long a[3][3];&#125;;node mul(node a,node b)&#123; node c; for(int i=1;i&lt;=2;i++) for(int j=1;j&lt;=2;j++) &#123; c.a[i][j]=0; for(int k=1;k&lt;=2;k++) c.a[i][j]+=(a.a[i][k]*b.a[k][j]); c.a[i][j]%=1000000007; &#125; return c;&#125;node qp(node a,int b)&#123; node ans; ans.a[1][1]=ans.a[1][2]=ans.a[2][1]=1; ans.a[2][2]=0; while(b) &#123; if(b&amp;1) ans=mul(ans,a); a=mul(a,a); b&gt;&gt;=1; &#125; return ans;&#125;int main()&#123; int n,t; scanf("%d",&amp;t); while(t--) &#123; scanf("%d",&amp;n); if(n==-1) break; node now; now.a[1][1]=now.a[1][2]=now.a[2][1]=1; now.a[2][2]=0; if(n==0) &#123; printf("0\n"); continue; &#125; if(n&lt;=2&amp;&amp;n&gt;0) printf("1\n"); else printf("%d\n",qp(now,n-2).a[1][1]); &#125;&#125;]]></content>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[莫比乌斯反演证明]]></title>
    <url>%2Funcategorized48%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ-1845 Sumdiv (基础数论综合)]]></title>
    <url>%2Funcategorized47%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;const ll mod=9901;ll p,bk[5005],sum[5005],q[5005];void fj(ll x)&#123; p=0; memset(sum,0,sizeof(sum)); for(int i=2;i*i&lt;=x+1;i++) &#123; if(x%i==0) &#123; q[++p]=i; while(x%i==0) sum[p]++,x/=i; &#125; &#125; if(x&gt;1) q[++p]=x,sum[p]=1;&#125;ll qpow(ll a,ll b)&#123; ll ans=1; ll base=a; while(b) &#123; if(b&amp;1) ans=ans%mod*base%mod,ans%=mod; base=base%mod*base%mod,base%=mod; b&gt;&gt;=1; &#125; return ans%mod;&#125;ll getsum(ll a,ll b)&#123; if(b==0) return 1; if(b%2==1) //奇数式 return ((1+qpow(a,(b+1)/2))*getsum(a,(b-1)/2)%mod)%mod; if(b%2==0) //偶数式 return ((1+qpow(a,b/2))*getsum(a,(b/2)-1)%mod+qpow(a,b))%mod;&#125;int main()&#123; ll n,m,ans=0; while(~scanf("%lld%lld",&amp;n,&amp;m)) &#123; fj(n); ans=1; for(int i=1;i&lt;=p;i++) &#123; ans=ans%mod*(getsum(q[i],sum[i]*m))%mod; ans%=mod; &#125; printf("%lld\n",ans%mod); &#125;&#125;]]></content>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1061 青蛙的约会(拓展欧几里得)]]></title>
    <url>%2Funcategorized46%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;cstdio&gt;void exgcd(long long a,long long b,long long &amp;x,long long &amp;y,long long &amp;d)&#123; if(!b) x=1,y=0,d=a; else exgcd(b,a%b,y,x,d),y-=a/b*x;&#125;using namespace std;int main()&#123; long long x,y,m,n,l; scanf("%lld%lld%lld%lld%lld",&amp;x,&amp;y,&amp;m,&amp;n,&amp;l); long long x0,y0,d0; long long a=n-m,b=l,c=x-y; exgcd(a,b,x0,y0,d0); if(c%d0!=0) printf("Impossible"); else &#123; x0*=c/d0; long long b0=b/d0; printf("%lld",(x0%b0+b0)%b0); &#125;&#125;]]></content>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客2 Second Large Rectangle]]></title>
    <url>%2Funcategorized44%2F</url>
    <content type="text"><![CDATA[题意求01矩阵第二大1矩阵的面积真实被教育，求二大的题一般都很贱，求一大的值完全就是板子题，随便上网找找就行我这说说二大的要点。首先错误的地方就是单调栈进去的都是当前最优的结果，所以我们会有一个hack的数据1 41 1 1 1答案显然是3但是我们会得到0…因为我们记录的都是当前最优最大的面积的矩形….解决方法多加入一些长减一或者宽减一之类的矩形然后就是寻找的时候好多bug,复杂的实现我就不说了,简易的实现就是把第一大面积第二大面积算出来然后再单调栈遍历一遍这个地方因为我们的复杂度大约n^2 1e6多点常数无所谓然后就是看看不重复的矩形的最大的面积是否会有多于一个等于最大值的有就直接输出最大值否则输出二大值即可.矩形判重直接用左上角右下角坐标或者是i*m+j之类的判别代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;using namespace std;long long st[1005],a[1005][1005],h[1005][1005],l[1005],r[1005],p,q;set&lt;int&gt; s;map&lt;long long,map&lt;long long,long long&gt;&gt; bk;int main()&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) &#123; char x; cin&gt;&gt;x; a[i][j]=x-'0'; &#125; for(int i=1;i&lt;=m;i++) for(int j=1;j&lt;=n;j++) if(a[j][i]==1) h[j][i]=h[j-1][i]+1; for(int i=1;i&lt;=n;i++) &#123; p=0; for(int j=1;j&lt;=m;j++) &#123; while(p&amp;&amp;h[i][st[p]]&gt;=h[i][j]) p--; if(p) l[j]=st[p]; else l[j]=0; st[++p]=j; &#125; p=0; for(int j=m;j;j--) &#123; while(p&amp;&amp;h[i][st[p]]&gt;=h[i][j]) p--; if(p) r[j]=st[p]; else r[j]=m+1; st[++p]=j; &#125; for(int j=1;j&lt;=m;j++) &#123; s.insert((r[j]-l[j]-1)*h[i][j]); s.insert((r[j]-l[j]-2)*h[i][j]); s.insert((r[j]-l[j]-1)*(h[i][j]-1)); &#125; &#125; auto it=s.end(); int m1=*(--it); int m2=*(--it); int num__ = 0; for(int i=1;i&lt;=n;i++) &#123; p=0; for(int j=1;j&lt;=m;j++) &#123; while(p&amp;&amp;h[i][st[p]]&gt;=h[i][j]) p--; if(p) l[j]=st[p]; else l[j]=0; st[++p]=j; &#125; p=0; for(int j=m;j;j--) &#123; while(p&amp;&amp;h[i][st[p]]&gt;=h[i][j]) p--; if(p) r[j]=st[p]; else r[j]=m+1; st[++p]=j; &#125; for(int j=1;j&lt;=m;j++) &#123; int now=(r[j]-l[j]-1)*h[i][j]; if(now==m1&amp;&amp;(!bk[(i-h[i][j])*m+(l[j]+1)][(i-1)*m+(r[j]-1)])) &#123; num__++; bk[(i-h[i][j])*m+(l[j]+1)][(i-1)*m+(r[j]-1)]=1; &#125; if(num__&gt;1) return printf("%d",m1),0; &#125; &#125; printf("%d",m2);&#125;]]></content>
      <tags>
        <tag>牛客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P1103 书本整理]]></title>
    <url>%2Funcategorized43%2F</url>
    <content type="text"><![CDATA[技巧比较强，如果正着想删除几本书那实在是太难了，我是白给了。倒着想留下几本书的话，我们可以判断当前书在序列中是留下的第几本，那么很容易想到每一本都有可能由前面的任意序列组合而成，最后再枚举第三个剩下的条件然后即可解决 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;struct node&#123; int h,w;&#125;a[105];int f[105][105],n,m,ans=1&lt;&lt;30;bool cmp(node a,node b)&#123; return a.h&lt;b.h;&#125;int main()&#123; memset(f,0x3f,sizeof(f)); scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) f[i][1]=0; m=n-m; for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;a[i].h,&amp;a[i].w); sort(a+1,a+1+n,cmp); for(int i=2;i&lt;=n;i++) for(int j=1;j&lt;i;j++) for(int k=2;k&lt;=min(m,i);k++) f[i][k]=min(f[i][k],f[j][k-1]+abs(a[i].w-a[j].w)); for(int i=m;i&lt;=n;i++) ans=min(ans,f[i][m]); printf("%d",ans);&#125;]]></content>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P2072 宗教问题]]></title>
    <url>%2Funcategorized45%2F</url>
    <content type="text"><![CDATA[很奇怪的dp，我是没有见过这种的之前，尤其是第二维倒着推，实际上就是把每种可能的分块情况枚举一遍,最后再输出答案,秒题 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;int bk[1005],a[1005],p=0,f1[1005],f2[1005];int main()&#123; int n,m,k; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); f1[1]=f2[1]=1; for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); for(int i=2;i&lt;=n;i++) &#123; f1[i]=1&lt;&lt;30; f2[i]=1&lt;&lt;30; memset(bk,0,sizeof(bk)); int sum=0; for(int j=i;j;j--) &#123; if(!bk[a[j]]) &#123; sum++; bk[a[j]]=1; &#125; if(sum&gt;k) break; f1[i]=min(f1[i],f1[j-1]+1); f2[i]=min(f2[i],f2[j-1]+sum); &#125; &#125; printf("%d\n%d",f1[n],f2[n]);&#125;]]></content>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1977 出租车拼车]]></title>
    <url>%2Funcategorized42%2F</url>
    <content type="text"><![CDATA[方程基本推对了就是转移的时候有点迷，实际上还要用f[i][j]=f[i-1][j]这样取min的时候才不会出错,然后就是就算越界也没事有点像背包 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;int f[105][105],w1[105],w2[105];int main()&#123; int a,b,c,d; memset(f,0x3f,sizeof(f)); f[0][0]=0; scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d); for(int i=1;i&lt;=b;i++) scanf("%d%d",&amp;w1[i],&amp;w2[i]); for(int i=1;i&lt;=b;i++) for(int j=0;j&lt;=a;j++) &#123; f[i][j]=f[i-1][j]; for(int k=0;k&lt;=min(j,w2[i]);k++) f[i][j]=min(f[i][j],f[i-1][j-k]+c+k*w1[i]); &#125; if(f[b][a]&gt;100000) printf("impossible"); else printf("%d",f[b][a]);&#125;]]></content>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1970花匠]]></title>
    <url>%2Funcategorized41%2F</url>
    <content type="text"><![CDATA[简约的一道dp小品好题，推着推着发现是一个交错的0,1数列，接着脑子就开始发晕不知道怎么能做的又快又好，看了题解之后发现每次只需要如果有大小变化就交错更新即可否则按照原样 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;int f[100005][3],a[100005];int main()&#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); for(int i=1;i&lt;=n;i++) f[i][0]=f[i][1]=1; for(int i=2;i&lt;=n;i++) &#123; if(a[i]&lt;a[i-1]) f[i][0]=f[i-1][1]+1; else f[i][0]=f[i-1][0]; if(a[i]&gt;a[i-1]) f[i][1]=f[i-1][0]+1; else f[i][1]=f[i-1][1]; &#125; printf("%d",max(f[n][0],f[n][1]));&#125;]]></content>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分图基础初步探究]]></title>
    <url>%2Funcategorized400%2F</url>
    <content type="text"><![CDATA[概述二分图判定很好说就是没有奇边环即可然后就是匈牙利算法了匈牙利算法求的是最大匹配集根据一个定理这也等于最小点覆盖集 匈牙利算法匈牙利算法原理是通过増广路实际上也不需要这么的复杂，核心在于我前面的两个点如果已经选了我再进行匹配的时候要怎么最优化道理在于先维护一个vis代表当前点遍历过后所有的点,这个vis巧妙而且必不可少因为如果这是保证切换寻找的时候不会出现重复的现象 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;int n,m,k,l[105],r[105],mp[105][105],vis[105],ans;int dfs(int p)&#123; for(int i=1;i&lt;=m;i++) if(mp[p][i]&amp;&amp;!vis[i]) &#123; vis[i]=1; if(!r[i]||dfs(r[i])) &#123; l[p]=i; r[i]=p; return 1; &#125; &#125; return 0;&#125;int main()&#123; while(~scanf("%d%d%d",&amp;n,&amp;m,&amp;k)) &#123; if(n==0) break; memset(mp,0,sizeof(mp)); memset(l,0,sizeof(l)); memset(r,0,sizeof(r)); for(int i=1;i&lt;=k;i++) &#123; int id,l,r; scanf("%d%d%d",&amp;id,&amp;l,&amp;r); mp[l][r]=1; &#125; ans=0; for(int i=1;i&lt;=n;i++) &#123; if(!l[i]) &#123; memset(vis,0,sizeof(vis)); ans+=dfs(i); &#125; &#125; printf("%d\n",ans); &#125;&#125; 最大权匹配集匈牙利算法的升级版，应用于左右互相最大的匹配边权和最大值,匈牙利算法的重复尝试在于连接性这里要加上边权的问题首先我们初始化左边的wl数组为边权最大的那条边的权值右边为0接着我们每次匹配如果出现了问题，需要重复匹配按照这样的规则:出现二夹一就要左加右减最后把答案统计即可 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;int wl[305],wr[305],vl[305],vr[305],cha[305],n,a[305][305],vrr[305];int dfs(int p)&#123; vl[p]=1; for(int i=1;i&lt;=n;i++) &#123; if(vr[i]) continue; int g=wl[p]+wr[i]-a[p][i]; if(g==0) &#123; vr[i]=1; if(!vrr[i]||dfs(vrr[i])) &#123; vrr[i]=p; return 1; &#125; &#125; else cha[i]=min(cha[i],g); &#125; return 0;&#125;int main()&#123; while(~scanf("%d",&amp;n)) &#123; memset(wl,0,sizeof(wl)); memset(wr,0,sizeof(wr)); memset(vrr,0,sizeof(vrr)); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) scanf("%d",&amp;a[i][j]); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) wl[i]=max(wl[i],a[i][j]); for(int i=1;i&lt;=n;i++) &#123; memset(cha,0x7f,sizeof(cha)); while(1) &#123; memset(vl,0,sizeof(vl)); memset(vr,0,sizeof(vr)); if(dfs(i)) break; int t=1&lt;&lt;30; for(int j=1;j&lt;=n;j++) if(!vr[j]) t=min(t,cha[j]); for(int j=1;j&lt;=n;j++) &#123; if(vl[j]) wl[j]-=t; if(vr[j]) wr[j]+=t; else cha[j]-=t; &#125; &#125; &#125; int ans=0; for(int i=1;i&lt;=n;i++) ans+=a[vrr[i]][i]; printf("%d\n",ans); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[二分图基础初步探究]]></title>
    <url>%2Funcategorized40%2F</url>
    <content type="text"><![CDATA[概述二分图判定很好说就是没有奇边环即可然后就是匈牙利算法了匈牙利算法求的是最大匹配集根据一个定理这也等于最小点覆盖集 匈牙利算法匈牙利算法原理是通过増广路实际上也不需要这么的复杂，核心在于我前面的两个点如果已经选了我再进行匹配的时候要怎么最优化道理在于先维护一个vis代表当前点遍历过后所有的点,这个vis巧妙而且必不可少因为如果这是保证切换寻找的时候不会出现重复的现象 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;int n,m,k,l[105],r[105],mp[105][105],vis[105],ans;int dfs(int p)&#123; for(int i=1;i&lt;=m;i++) if(mp[p][i]&amp;&amp;!vis[i]) &#123; vis[i]=1; if(!r[i]||dfs(r[i])) &#123; l[p]=i; r[i]=p; return 1; &#125; &#125; return 0;&#125;int main()&#123; while(~scanf("%d%d%d",&amp;n,&amp;m,&amp;k)) &#123; if(n==0) break; memset(mp,0,sizeof(mp)); memset(l,0,sizeof(l)); memset(r,0,sizeof(r)); for(int i=1;i&lt;=k;i++) &#123; int id,l,r; scanf("%d%d%d",&amp;id,&amp;l,&amp;r); mp[l][r]=1; &#125; ans=0; for(int i=1;i&lt;=n;i++) &#123; if(!l[i]) &#123; memset(vis,0,sizeof(vis)); ans+=dfs(i); &#125; &#125; printf("%d\n",ans); &#125;&#125; 最大权匹配集匈牙利算法的升级版，应用于左右互相最大的匹配边权和最大值,匈牙利算法的重复尝试在于连接性这里要加上边权的问题首先我们初始化左边的wl数组为边权最大的那条边的权值右边为0接着我们每次匹配如果出现了问题，需要重复匹配按照这样的规则:出现二夹一就要左加右减最后把答案统计即可 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;int wl[305],wr[305],vl[305],vr[305],cha[305],n,a[305][305],vrr[305];int dfs(int p)&#123; vl[p]=1; for(int i=1;i&lt;=n;i++) &#123; if(vr[i]) continue; int g=wl[p]+wr[i]-a[p][i]; if(g==0) &#123; vr[i]=1; if(!vrr[i]||dfs(vrr[i])) &#123; vrr[i]=p; return 1; &#125; &#125; else cha[i]=min(cha[i],g); &#125; return 0;&#125;int main()&#123; while(~scanf("%d",&amp;n)) &#123; memset(wl,0,sizeof(wl)); memset(wr,0,sizeof(wr)); memset(vrr,0,sizeof(vrr)); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) scanf("%d",&amp;a[i][j]); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) wl[i]=max(wl[i],a[i][j]); for(int i=1;i&lt;=n;i++) &#123; memset(cha,0x7f,sizeof(cha)); while(1) &#123; memset(vl,0,sizeof(vl)); memset(vr,0,sizeof(vr)); if(dfs(i)) break; int t=1&lt;&lt;30; for(int j=1;j&lt;=n;j++) if(!vr[j]) t=min(t,cha[j]); for(int j=1;j&lt;=n;j++) &#123; if(vl[j]) wl[j]-=t; if(vr[j]) wr[j]+=t; else cha[j]-=t; &#125; &#125; &#125; int ans=0; for(int i=1;i&lt;=n;i++) ans+=a[vrr[i]][i]; printf("%d\n",ans); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[JOIOJI]]></title>
    <url>%2F%E7%AE%97%E6%B3%9539%2F</url>
    <content type="text"><![CDATA[最好想的就是维护三个前缀和JOI的然后使得J[r]-J[l]==O[r]-O[l]==I[r]-I[l],显然r可以一步一步1-&gt;n但是l是一个问题直接枚举会超时怎么办????骚气解法维护一个pair的map,为什么用pair因为省事不用重载小于号你用node也可以那样要重载小于号,实际上也是殊途同归.然后我们就维护一下任意两个的差啥叫任意也就是(x-y,y-z)(x-z,z-y)随便任意两个但是要保证这个格式.然后设置(0,0)为0.这是什么格式?首先我们模拟肯定能验证他的正确性,然后我们可以发现如果我后续的二元组跟前面的有相同的,那么我们可以断定一个事.比如我现在用的是(x-y,y-z)的格式,那么我现在的xr-yr,yr-zr与前面的xl-yl,yl-zl相等了也就说明二元组内每个元素都相等就是说明xr-yr=xl-yl ==&gt; xr-xl=yr-yl右边同理不就是我们要找的东西吗. 代码1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;char s[200005];map&lt;pair&lt;int,int&gt;,int&gt; bk;int _j,_o,_i,ans;int main()&#123; int n; scanf("%d%s",&amp;n,s+1); bk[make_pair(0,0)]=0; for(int i=1;i&lt;=n;i++) &#123; if(s[i]=='J') _j++; else if(s[i]=='O') _o++; else _i++; int x=_j-_o,y=_o-_i; if(!bk[make_pair(x,y)]&amp;&amp;(x!=0||y!=0)) bk[make_pair(x,y)]=i; else ans=max(ans,i-bk[make_pair(x,y)]); &#125; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nim23]]></title>
    <url>%2Funcategorizednim23%2F</url>
    <content type="text"><![CDATA[博弈小游戏 body { background-image: url("https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1559763394992&di=f817502b4cc4321c00714a88edc4c4b0&imgtype=0&src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20170828%2Fab4eaea5e401470abb0a0458354221da.jpeg"); background-size: cover; background-repeat: no-repeat; } h1.title { font-size: 180px; text-align: center; color: blue; } p.startmenu { font-size: 120px; text-align: center; color: red; } p.startmenu_ { font-size: 120px; text-align: center; color: red; } p.startmenu:hover { color:orange; } p.startmenu_:hover { color:orange; } h1.startinfo_ { font-size: 60px; color: blue; } h1.heng { width: 85%; height: 5%; margin: auto; position: absolute; top: 80%; left: 5%; background-color: brown; border-style: outset; } h1.round { position: absolute; top: 1%; right: 5%; color:orange; font-size: 60px; } p.ticks { position: absolute; top: 15%; right: 5%; color: #a600ff; font-size: 80px; } #one { background-color: red; border-style: ridge; width: 10%; position:absolute; left:10%; height: 3.5%; } #two { background-color: red; width: 10%; border-style: ridge; position:absolute; left:25%; height: 3.5%; } #three { background-color: red; width: 10%; border-style: ridge; position:absolute; left:40%; height: 3.5%; } #four { background-color: red; width: 10%; border-style: ridge; position:absolute; left:55%; height: 3.5%; } #five { background-color: red; width: 10%; border-style: ridge; position:absolute; left:70%; height: 3.5%; } #one_ { color: white; font-size: 80px; position: absolute; left: 10%; top: 82%; } #two_ { color: white; font-size: 80px; position: absolute; left: 25%; top: 82%; } #three_ { color: white; font-size: 80px; position: absolute; left: 40%; top: 82%; } #four_ { color: white; font-size: 80px; position: absolute; left: 55%; top: 82%; } #five_ { color: white; font-size: 80px; position: absolute; left: 70%; top: 82%; } #one:hover { background-color: cyan; } #two:hover { background-color: cyan; } #three:hover { background-color: cyan; } #four:hover { background-color: cyan; } #five:hover { background-color: cyan; } #atfo { text-align: center; font-size: 60px; color: blue; } #end_ { font-size: 120px; text-align: center; color: red; } #end_:hover { color: orange; } h1.chaofeng { text-align: center; font-size: 60px; color: purple; } p.heap1:hover { background-color: cyan; } &lt;/style&gt; 取金币博弈 开始 制作详情 考Java前的浪作美化UI肝到了晚上的1点半快,感觉已经 相当不错了，具体的制作是用了html+css+jquery具体可以自己看源代码。 游戏紧张刺激,尝试着去击败电脑吧!!!!策划:刘凯制作:马鸿儒 JAVA考炸了.....！！！！ 返回 游戏的规则相当的简单，现在桌上有5堆金币，每一个回合当前的玩家需要任选一堆拿走 至少一个金币，不能当前回合一个不拿，谁先拿完最后一个金币谁就获胜，现在请你选择你的游戏模式及先后手顺序。 试着挑战我精心准备的AI吧！！！ 随机局面 自定义局面 先手 后手 回合 重新来过? //$("body").css("background-color","blue"); $("#end_").hide(); $("h1.startinfo_").hide(); $("#xianshou").hide(); $("#houshou").hide(); $("h1.heng").hide(); $("h1.round").hide(); $("p.ticks").hide(); $("#one").hide(); $("#two").hide(); $("#three").hide(); $("#four").hide(); $("#five").hide(); $("#one_").hide(); $("#two_").hide(); $("#three_").hide(); $("#four_").hide(); $("#five_").hide(); $("#atfo").hide(); $("#back").hide(); $("end_").hide(); $("h1.chaofeng").hide(); $("p.kuai").hide(); $("#mod1").hide(); $("#mod2").hide(); var heap=new Array(); var ticks=1; var cnt=0; var ff=0; $("#start").click( function() { $("#xuanze")[0].play(); $("h1.title").fadeOut(); $("#start").fadeOut(); $("#author").fadeOut(); $("h1.startinfo_").fadeIn(300); $("#mod1").fadeIn(300); $("#mod2").fadeIn(300); //$("#xianshou").fadeIn(300); //$("#houshou").fadeIn(300); $("h1.chaofeng").fadeIn(300); } ) $("p.startmenu_").click( function() { $("#xuanze")[0].play(); $("h1.title").fadeOut(); $("#start").fadeOut(); $("#author").fadeOut(); $("#atfo").fadeIn(); $("#back").fadeIn(); $("#back").click( function() { $("#xuanze")[0].play(); $("#atfo").fadeOut(300); $("#back").fadeOut(300); $("h1.title").fadeIn(); $("#start").fadeIn(); $("#author").fadeIn(); } ); } ); $("#mod1").click( function() { $("#xuanze")[0].play(); mod=1; $("#mod1").fadeOut(); $("#mod2").fadeOut(); $("#xianshou").fadeIn(300); $("#houshou").fadeIn(300); } ) $("#mod2").click( function() { $("#xuanze")[0].play(); mod=2; $("#mod1").fadeOut(); $("#mod2").fadeOut(); $("#xianshou").fadeIn(300); $("#houshou").fadeIn(300); } ) $("#xianshou").click( function() { $("#xuanze")[0].play(); $("h1.chaofeng").fadeOut(); game(); } ) $("#houshou").click( function() { $("#xuanze")[0].play(); $("h1.chaofeng").fadeOut(); game2(); } ) function game2() { $("h1.startinfo_").fadeOut(); $("#xianshou").fadeOut(); $("#houshou").fadeOut(); $("h1.heng").fadeIn(300); $("h1.round").fadeIn(300); $("p.ticks").text(ticks); $("p.ticks").fadeIn(300); if(mod==1) { while(1) { for(var i=1;i]]></content>
      <tags>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nim]]></title>
    <url>%2Funcategorizednim%2F</url>
    <content type="text"><![CDATA[body { background-image: url("https://s2.ax1x.com/2019/06/05/VUtZkt.jpg"); } h1.title { font-size: 180px; text-align: center; color: blue; } p.startmenu { font-size: 120px; text-align: center; color: red; } p.startmenu_ { font-size: 120px; text-align: center; color: red; } p.startmenu:hover { color:orange; } p.startmenu_:hover { color:orange; } h1.startinfo_ { font-size: 60px; color: blue; } h1.heng { width: 85%; height: 5%; margin: auto; position: absolute; top: 80%; left: 5%; background-color: brown; border-style: outset; } h1.round { position: absolute; top: 1%; right: 5%; color:orange; font-size: 60px; } p.ticks { position: absolute; top: 15%; right: 5%; color: #a600ff; font-size: 80px; } #one { background-color: red; border-style: ridge; width: 10%; position:absolute; left:10%; } #two { background-color: red; width: 10%; border-style: ridge; position:absolute; left:25%; } #three { background-color: red; width: 10%; border-style: ridge; position:absolute; left:40%; } #four { background-color: red; width: 10%; border-style: ridge; position:absolute; left:55%; } #five { background-color: red; width: 10%; border-style: ridge; position:absolute; left:70%; } #one_ { color: white; font-size: 80px; position: absolute; left: 10%; top: 82%; } #two_ { color: white; font-size: 80px; position: absolute; left: 25%; top: 82%; } #three_ { color: white; font-size: 80px; position: absolute; left: 40%; top: 82%; } #four_ { color: white; font-size: 80px; position: absolute; left: 55%; top: 82%; } #five_ { color: white; font-size: 80px; position: absolute; left: 70%; top: 82%; } #one:hover { background-color: cyan; } #two:hover { background-color: cyan; } #three:hover { background-color: cyan; } #four:hover { background-color: cyan; } #five:hover { background-color: cyan; } #atfo { text-align: center; font-size: 60px; color: blue; } #end_ { font-size: 120px; text-align: center; color: red; } #end_:hover { color: orange; } h1.chaofeng { text-align: center; font-size: 60px; color: purple; } 博弈小游戏 开始 制作详情 NIM博弈经典小游戏,尝试着去击败电脑吧!!!! 返回 游戏的规则相当的简单，现在桌上有5堆硬币，每一个回合当前的玩家需要任选一堆拿走至少一个硬 币，不能当前回合一个不拿，谁拿走最后一个硬币谁就获胜，现在请你选择你的先后手顺序。 试着挑战我精心准备的AI吧！！！ 先手 后手 回合 重新来过? L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/assets/hibiki.model.json"},"display":{"position":"left","width":100,"height":300},"mobile":{"show":false},"log":false,"tagMode":false});]]></content>
  </entry>
  <entry>
    <title><![CDATA[论如何补一道南昌网络赛的题补一上午]]></title>
    <url>%2F%E7%AE%97%E6%B3%9538%2F</url>
    <content type="text"><![CDATA[先上题目 比赛的时候当时网络赛做这个题的时候，队内又信息交流出问题，让我一直以为是找区间内的最左边的数乘以这个区间的加和算最大值心想dnmd这个怎么可能不用O(N^2)算法?于是果断放弃。。。 周一回来周一回来重新打开QQ群发现了题解说用单调栈来求解，心想单调栈怎么还能解决这个问题？于是问了问大哥题意是啥后才发现题意都读错了，于是赶紧开始了补题 第一次尝试首先看到这个题再加上看到单调栈的字眼很容易就想到一个O(3*N)的算法就是O(N)左边扫一遍O(N)右边扫一遍O(N)总共的扫一遍求最大值于是写下了这样的代码 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;long long ans=0,l[500005],r[500005],pre[500005],num[500005];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;num[i]; pre[i]=pre[i-1]+num[i]; &#125; stack&lt;int&gt; st; for(int i=1;i&lt;=n;i++) &#123; while(st.size()&amp;&amp;num[st.top()]&gt;=num[i]) st.pop(); if(st.size()) l[i]=st.top()+1; else l[i]=1; st.push(i); &#125; while(st.size()) st.pop(); for(int i=n;i;i--) &#123; while(st.size()&amp;&amp;num[st.top()]&gt;=num[i]) st.pop(); if(st.size()) r[i]=st.top()-1; else r[i]=n; st.push(i); &#125; for(int i=1;i&lt;=n;i++) ans=max(ans,1LL*(pre[r[i]]-pre[l[i]-1])*num[i]); cout&lt;&lt;ans;&#125; 看着也是十分的简洁明了的，但是WA。。。队友说你怕是只能过两个点。。。发现真的就过了两个点。。。然后开始听说有负数要特判，但是我当时还是完全的不明白为啥要特判啊于是索要hack数据。。。队友拿出了:5-7 -8 1 -7 -8这个答案应该是232，留下这一句话开始漏出了笑容，似乎已经预料到我程序要白给了，但是神奇的是我的程序正好出现了232….这也让我很奇怪，都说这个数据可能会出问题为啥我的没有出问题，虽然我那时候还是觉得不需要负数特判但是我还是自己hack了一波我自己除了一波:30 1 2结果我的程序出来个4我以为hack成功，还没来得及高兴就发现好像单个2*2就是4哦…于是陷入了僵局提交果然也是wa 2/13于是乎问了问校外的大佬咋回事啊，大佬很不屑的来了一组:51 -2 -3 -4 -5我也就试了试出来个65…但是答案显然是70hack成功!!!我开始分析哪里出了问题发现这个左右边界有可能取的过于大了导致不是区间和最优的情况，对于负数来说区间和尽量的是负数才有可能找到最大的值，于是我开始了第一波修改 第二次尝试我想着我把前缀后缀求出来然后枚举l-r内的最小前缀后缀不就可以了吗？于是负数我这样特判: 12345678long long minn=INT_MAX;for(int j=l[i];j&lt;=r[i];j++)&#123; minn=min(minn,pre[r[i]]-pre[j-1]); minn=min(minn,post[j]-post[r[i]+1]);&#125;minn=min(minn,num[i]);ans=max(ans,num[i]*minn*1LL); 这个也过了大佬给的hack但是交上去还是wa 2/13…后来我自己随意hack了一波发现还是不对:51 -2 -3 -2 1答案显然是21但是我的程序是18…经过思考发现我这样做不能随意截断导致必须跟着前面的也就是说如果3-5是最优的那么我肯定会把1-2算上算成1-5是最优的显然这是不对的我又陷入了沉思… 第三次尝试实在想不出来问大佬大佬抛了一句看题解，于是我又借鉴了别人的找法，以当前的数为中心枚举左边的前缀和并且枚举右边的前缀和即可这样直接就能保证可以出现了截断式的最优解，问题显得迎刃而解了通过修改后我的代码为: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;long long ans=-INT_MAX,l[500005],r[500005],pre[500005],num[500005],post[500005];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;num[i]; pre[i]=pre[i-1]+num[i]; &#125; for(int i=n;i;i--) post[i]=post[i+1]+num[i]; stack&lt;int&gt; st; for(int i=1;i&lt;=n;i++) &#123; while(st.size()&amp;&amp;num[st.top()]&gt;=num[i]) st.pop(); if(st.size()) l[i]=st.top()+1; else l[i]=1; st.push(i); &#125; while(st.size()) st.pop(); for(int i=n;i;i--) &#123; while(st.size()&amp;&amp;num[st.top()]&gt;=num[i]) st.pop(); if(st.size()) r[i]=st.top()-1; else r[i]=n; st.push(i); &#125; for(int i=1;i&lt;=n;i++) &#123; if(num[i]&gt;=0) ans=max(ans,1LL*(pre[r[i]]-pre[l[i]-1])*num[i]); else &#123; long long minn1=INT_MAX,minn2=INT_MAX; for(int j=l[i];j&lt;=i;j++) minn1=min(minn1,pre[i]-pre[j-1]); for(int j=i+1;j&lt;=r[i];j++) minn2=min(minn2,pre[j]-pre[i]); ans=max(ans,num[i]*(minn1+minn2)*1LL); &#125; &#125; cout&lt;&lt;ans;&#125; 我自己的hack都过了心想可算结束了，但是交上去还是不对。。。wa 12/13….这就相当的神奇了，我这个bug也是想了好久好久问了别人别人也都没有怎么看出来… 第四次尝试最终我心想算了，直接把别人的手敲一份记他的写法吧可能我的写法哪里有问题，但是敲别人的我也白给一直不对，经过一阵子的debug突然发现第二个for有可能是不走的也就是说对于这个代码: 123456long long minn1=INT_MAX,minn2=INT_MAX;for(int j=l[i];j&lt;=i;j++)minn1=min(minn1,pre[i]-pre[j-1]);for(int j=i+1;j&lt;=r[i];j++)minn2=min(minn2,pre[j]-pre[i]);ans=max(ans,num[i]*(minn1+minn2)*1LL); 第二个for有可能是不走的！！！于是我赶紧把我自己的代码修改了一下这部分替换成 123456789long long minn1=INT_MAX,minn2=INT_MAX;for(int j=l[i];j&lt;=i;j++)minn1=min(minn1,pre[i]-pre[j-1]);ans=max(ans,num[i]*minn1);for(int j=i+1;j&lt;=r[i];j++)&#123; minn2=min(minn2,pre[j]-pre[i]); ans=max(ans,num[i]*(minn1+minn2)*1LL);&#125; 交上去可算AC了…..- = 感慨总的来说还是太嫩了，虽然看着是个模板题但是里面也是暗藏玄机…写着写着我就开始不注意了…代码能力还是很弱,如果说这个题解法的话就是利用单调栈的性质求助以每个数为最小值的可能的最大的边界，这样需要左右各扫一遍然后再线性扫一遍求解，负数特判确实是相当的毒瘤。。。总体复杂度的话是O(3*N+N^2) N^2部分看起来应该是比较少没有卡掉这个题。。。也算是出的不好吧，但是如果不这么做的话又没有别的思路，至少我是没有别的思路的…AC代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;long long ans=0,l[500005],r[500005],pre[500005],num[500005];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;num[i]; pre[i]=pre[i-1]+num[i]; &#125; stack&lt;int&gt; st; for(int i=1;i&lt;=n;i++) &#123; while(st.size()&amp;&amp;num[st.top()]&gt;=num[i]) st.pop(); if(st.size()) l[i]=st.top()+1; else l[i]=1; st.push(i); &#125; while(st.size()) st.pop(); for(int i=n;i;i--) &#123; while(st.size()&amp;&amp;num[st.top()]&gt;=num[i]) st.pop(); if(st.size()) r[i]=st.top()-1; else r[i]=n; st.push(i); &#125; for(int i=1;i&lt;=n;i++) &#123; if(num[i]&gt;=0) ans=max(ans,1LL*(pre[r[i]]-pre[l[i]-1])*num[i]); else &#123; long long minn1=INT_MAX,minn2=INT_MAX; for(int j=l[i];j&lt;=i;j++) minn1=min(minn1,pre[i]-pre[j-1]); ans=max(ans,num[i]*minn1); for(int j=i+1;j&lt;=r[i];j++) &#123; minn2=min(minn2,pre[j]-pre[i]); ans=max(ans,num[i]*(minn1+minn2)*1LL); &#125; &#125; &#125; cout&lt;&lt;ans;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT 1013 Battle Over Cities (25 分)]]></title>
    <url>%2F%E7%AE%97%E6%B3%9537%2F</url>
    <content type="text"><![CDATA[题意就是问你图中去掉一个点剩余的部分需要最少修几条路可以再次保证联通？ 解法我最初是想着把他们弄成点，然后10分，看网上老哥做法是看成联通快，把剩余的部分看成图，最后求图路径就是联通块个数-1即可 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; G[2333];int mk[2333],ans[2333],sum;void dfs(int p)&#123; for(int i=0;i&lt;G[p].size();i++) if(!mk[G[p][i]]) &#123; mk[G[p][i]]=1; dfs(G[p][i]); &#125;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,m,k; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; while(m--) &#123; int st,ed; cin&gt;&gt;st&gt;&gt;ed; G[st].push_back(ed); G[ed].push_back(st); &#125; while(k--) &#123; int now; cin&gt;&gt;now; int sum=0; memset(mk,0,sizeof(mk)); mk[now]=1; for(int j=1;j&lt;=n;j++) if(!mk[j]) &#123; dfs(j); sum++; &#125; cout&lt;&lt;sum-1&lt;&lt;"\n"; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博弈论基础入门]]></title>
    <url>%2F%E7%AE%97%E6%B3%9536%2F</url>
    <content type="text"><![CDATA[bash game情况介绍两个顶尖聪明的人在玩游戏，有n个石子，每人可以随便拿1−m个石子，不能拿的人为败者，问谁会胜利 分析可以想到如果最终剩下m+1个石子，那么肯定先手必败。那么我们想到推出其他的m+1的倍数也就是说如果n%(m+1)!=0也就是说n=k(m+1)+r (k,r为常数)那么我们先手可以完全先拿走r个石子然后后手不管你怎么拿我先手只要凑够m+1就行了最终肯定是先手能够获胜反之如果n=k(m+1)那么后手必胜所以我们可以得到最终代码 1234if(n%(m+1))cout&lt;&lt;"first\n";elsecout&lt;&lt;"second\n"; 威佐夫博弈情况介绍有两堆各若干个物品，两个人轮流从任意一堆中取出至少一个或者同时从两堆中取出同样多的物品，规定每次至少取一个，至多不限，最后取光者胜利。 分析具体的推理我就不说了，网上各种推理。也就是说我们要判断当前状态(a,b)是否可以先手胜利的条件是求a,b的最大值然后求出差值来b-a然后看看(b-a)* r是不是等于a其中r是(1+sqrt(5))/2 1234567891011int n,m;cin&gt;&gt;n&gt;&gt;m;int t1=min(n,m);int t2=max(n,m);int t3=t2-t1;double r=(1+sqrt(5))/2;int t4=r*t3;if(t4==t1)cout&lt;&lt;"Yes";elsecout&lt;&lt;"no"; Nim game情况介绍有三堆各若干个物品，两个人轮流从某一堆取任意多的物品，规定每次至少取一个，多者不限，最后取光者得胜。 分析这个就是一个比较常见的会出现变形的首先接受NPN为必胜点P为必败点也就是说当前如果是N点那么经过两者的正确的操作那么先手必胜P点也是这样其中包含三个性质①N至少存在一种进入P②P只能进入N③所有的终结一定是P也就是说如果当前是P那么下一点必须是N如果要判断当前情况是不是N那么我们可以把当前的所有的数异或一下然后看看是不是等于0如果等于0那么就是一个P否则是一个N这也就是nim和 12345678910int sum=0;for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;num[i]; sum^=num[i];&#125;if(sum)cout&lt;&lt;"Yes";elsecout&lt;&lt;"no"; SG函数一看到这个我就想到csgo的SG553我自称他为帅哥函数或者傻狗函数。。。 分析SG函数可以直接求出当前节点的NP属性如果SG[n]大于0那么代表当前的n是一个N否则是P 求解SG函数靠递推求解，保证每次S集合都要清空即可 123456789101112for(int i=1;i&lt;=n;i++)&#123; memset(s,0,sizeof(s)); for(int j=1;i-f[j]&gt;=0&amp;&amp;j&lt;=N;j++) //求解当前延伸 s[sg[i-f[j]]]=1; for(int j=0;;j++) //求解最小的没有出现的整数 if(!s[j]) &#123; sg[i]=j break; &#125;&#125; 应用sg函数的f数组是分解的方式，也就是说如何分解。SG函数也是靠着分解然后一步一步递推的然后就是如果有多个状态求他们的nim和即可也就是如果有三堆a,b,c那么求个sg[a]^sg[b]^sg[c]即可]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EXKMP模板小结]]></title>
    <url>%2F%E7%AE%97%E6%B3%9535%2F</url>
    <content type="text"><![CDATA[胡乱分析什么是EXKMP?kmp就是当前这一部分的前缀与后缀的一个最大等值，然后等着线性匹配的时候如果出现了失配那么能够快速匹配到位的一种算法那么既然是EXKMP那么肯定是要有EX的部分的，那一部分就是EXKMP是子串与所有的主串所匹配的最大前缀长度例子aabbabaaabaabb4 1 0 0 1 0 2 3 1 0aabb跟主串第一个位置是有最大的4个前缀长度，第二个位置只有一个a最大其他的同理 EXKMP怎么实现?首先我们需要两个数组也就是子串的next数组这里的next数组和kmp的不一样是上面说的全部的匹配然后一个主串的ex数组存的就是答案具体的证明可以看这位大佬的博文 模板需要注意的事项实际上具体的实现的步骤就是复读两遍一个同样的算法首先计算子串的的next数组，先暴力出第二个第一个就是lenb然后从第三个开始计算k代表当前所运行的位置p代表最大的匹配的范围l是一个计算的变量其中p=k+next[k]-1 l=next[i-k+1]判断一下如果i+l&lt;p+1那么直接next[i]=l否则进行下一波的匹配令j=p-i+1然后接着匹配b[j]与b[i+j]看是否能相等最后把next[i]=j即可更新一下k匹配的时候同理不同的地方就是l=next[i-k+1]不是l=ex[i-k+1] 代码#include &lt;bits/stdc++.h&gt; using namespace std; char a[10005],b[10005]; int la,lb,nex[10005],ex[10005]; void exkmp() { nex[1]=lb; int x=1; while(b[x]==b[x+1]&amp;&amp;x+1&lt;=lb) x++; nex[2]=x-1; int k=2; for(int i=3;i&lt;=lb;i++) { int p=k+nex[k]-1; int l=nex[i-k+1]; if(i+l&lt;p+1) nex[i]=l; else { int j=p-i+1; if(j&lt;0) j=0; while(b[j+1]==b[i+j]&amp;&amp;i+j&lt;=lb) j++; nex[i]=j; k=i; } } x=1; while(a[x]==b[x]&amp;&amp;x&lt;=lb) x++; ex[1]=x-1; k=1; for(int i=2;i&lt;=la;i++) { int p=k+ex[k]-1; int l=nex[i-k+1]; if(i+l&lt;p+1) ex[i]=l; else { int j=p-i+1; if(j&lt;0) j=0; while(b[j+1]==a[i+j]&amp;&amp;i+j&lt;=la&amp;&amp;j&lt;=lb) j++; ex[i]=j; k=i; } } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin&gt;&gt;a+1&gt;&gt;b+1; la=strlen(a+1); lb=strlen(b+1); exkmp(); for(int i=1;i&lt;=la;i++) cout&lt;&lt;ex[i]&lt;&lt;" "; }]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树形DP(4) 最小覆盖集点与边的分别的做法]]></title>
    <url>%2F%E7%AE%97%E6%B3%9534%2F</url>
    <content type="text"><![CDATA[胡乱分析最小覆盖集的问题就是问你最少放多少个节点的东西使得所有的节点或者边被全部的覆盖，其中规定当前节点只能覆盖相邻的节点或者边首先这类问题分为两类一种是边全部覆盖，一种是点全部覆盖。 边全部覆盖问题首先谈一下边全部覆盖的时候的情况如果要边全部覆盖，那么我们可以发现一个问题，就是当前的每一个节点都包含两种情况那就是放上或者不放上如果我们把dp[p][1]代表当前节点要放上东西把dp[p][0]代表当前节点不放东西的话,那么我们可以得出一个简单的状态转移方程dp[p][1]+=min(dp[v][1],dp[v][0])dp[p][0]+=dp[v][1]其中v是儿子节点也就是说如果当前节点要放的话那么儿子节点可放可不放我们需要取一个min,如果当前节点不放的话那么儿子一定要放上一个 代码(poj 1463)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; G[6505];int dp[6505][6],bk[6505];void dfs(int p)&#123; dp[p][1]=1; dp[p][0]=0; for(int i=0;i&lt;G[p].size();i++) dfs(G[p][i]); for(int i=0;i&lt;G[p].size();i++) &#123; dp[p][1]+=min(dp[G[p][i]][0],dp[G[p][i]][1]); dp[p][0]+=dp[G[p][i]][1]; &#125;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; while(cin&gt;&gt;n) &#123; for(int i=0;i&lt;n;i++) G[i].clear(); memset(dp,0,sizeof(dp)); memset(bk,-1,sizeof(bk)); for(int i=0;i&lt;n;i++) &#123; int st,m; char a,b,c; cin&gt;&gt;st&gt;&gt;a&gt;&gt;b&gt;&gt;m&gt;&gt;c; while(m--) &#123; int ed; cin&gt;&gt;ed; bk[ed]=st; G[st].push_back(ed); &#125; &#125; int rt=0; while(bk[rt]!=-1) rt=bk[rt]; dfs(rt); cout&lt;&lt;min(dp[rt][0],dp[rt][1])&lt;&lt;"\n"; &#125;&#125; 点全部覆盖问题这个看上去好像跟边全部覆盖是一个意思的但是有不同。比如这组数据71 21 32 42 53 66 7这里如果是边覆盖那么是3,点覆盖那么是2为什么会这样？因为我们边覆盖如果要覆盖父亲节点,那么我们与所有儿子节点的边必须都得被覆盖，也就是如果父亲节点不放的话,那么儿子节点一定得放上,但是点覆盖不一样，我们的一个儿子只要放上那么这个父亲节点就已经被覆盖了所以我们得想别的办法搞了快一晚上这个问题还是凯哥最后解决了这个问题。。。用贪心算法也就是选择当前最好的选择我们定义两个记录的数组bk 和 okbk是当前节点是不是放一个 ok是代表这个节点是不是已经遍历过了这样我们的贪心策略就是看当前节点的父节点如果父节点没有被放上那么我们就把当前的父节点放上然后子节点和祖父节点全部都放上被遍历过的标记这里还延伸除了另一个问题就是我们回溯的时候要把这个贪心的代码放在哪个地方？我最初的时候想的是和dp一样直接放在dfs后面每次回溯都计算但是我得到了一个wa凯哥给的答案是放在最后回溯也就是遍历完所有的子节点之后再回溯并且给出了一个反例如果当前的子节点的左孩子是一个叶子节点但是右儿子不是叶子节点的话那么就会出现问题，所以要每次遍历之后回溯 代码(poj 3659)123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; G[10005];int bk[10005],mk[10005],f[10005],ans;int ok[10005];void dfs(int p,int fa)&#123; f[p]=fa; for(int i=0;i&lt;G[p].size();i++) if(G[p][i]!=fa) &#123; f[G[p][i]]=p; dfs(G[p][i],p); &#125; if(!ok[p]) &#123; if(!bk[fa]) &#123; ans++; bk[fa]=1; ok[fa]=1; ok[p]=1; ok[f[fa]]=1; &#125; else ok[p]=1; &#125;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; cin&gt;&gt;n; for(int i=1;i&lt;n;i++) &#123; int st,ed; cin&gt;&gt;st&gt;&gt;ed; G[ed].push_back(st); G[st].push_back(ed); &#125; dfs(1,1); cout&lt;&lt;ans;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树形DP(3)求树的重心]]></title>
    <url>%2F%E7%AE%97%E6%B3%9533%2F</url>
    <content type="text"><![CDATA[胡乱分析定义:树的重心也叫树的质心。找到一个点,其所有的子树中最大的子树节点数最少,那么这个点就是这棵树的重心,删去重心后，生成的多棵树尽可能平衡。也就是说第一步要去寻找所有的子树中的最大的子树节点，第二步去比较这个值与总的大小即可 代码(poj 3107 Godfather)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;using namespace std;int maxn[600005],sum[600005],head[600005],minn=99999999,n,cnt=1;struct node&#123; int v,next;&#125;G[600005];void add(int st,int ed)&#123; G[cnt].v=ed; G[cnt].next=head[st]; head[st]=cnt++;&#125;int dfs(int p,int fa)&#123; if(sum[p]) //剪枝 return sum[p]; sum[p]=1; //初始化每个节点都具有1 for(int i=head[p];i;i=G[i].next) &#123; if(G[i].v!=fa) //链式前向星遍历所有的边 &#123; sum[p]+=dfs(G[i].v,p); //sum遍历所有的子树 maxn[p]=max(maxn[p],sum[G[i].v]); //回溯记录每个节点的maxn &#125; &#125; maxn[p]=max(maxn[p],n-sum[p]); //这里还要找一下父亲部分，儿子部分和父亲部分比一个最大值 minn=min(minn,maxn[p]); //然后寻找答案最小值即可 return sum[p];&#125;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n-1;i++) &#123; int st,ed; scanf("%d%d",&amp;st,&amp;ed); add(st,ed); add(ed,st); &#125; dfs(1,1); for(int i=1;i&lt;=n;i++) if(maxn[i]==minn) cout&lt;&lt;i&lt;&lt;" ";&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树区间合并板子]]></title>
    <url>%2F%E7%AE%97%E6%B3%9532%2F</url>
    <content type="text"><![CDATA[胡乱分析区间合并操作指的是在给定的区间内，计算出例如10111011中的最大1的个数 分组解析build操作build操作与之前的求值的build操作一样，初始化的时候ls,rs,ms都是r+1-l初始化区间都是1 12345678910void build(int p,int l,int r)&#123; t[p].l=l;t[p].r=r; t[p].ls=t[p].rs=t[p].ms=r+1-l; if(l==r) return; int mid=(t[p].l+t[p].r)&gt;&gt;1; build(p&lt;&lt;1,l,mid); build(p&lt;&lt;1|1,mid+1,r);&#125; change操作这个题是单点的更改，change操作与之前不同的地方在于push_up操作原先的push_up仅仅只是把值修改一下这里修改的是区间的长度，所以有所不同首先更新ls ls=左的lsrs=右的rsms=等于左的ms右的ms和中间右左左右的加和的最大值其中如果ls溢出那么加上右的左rs溢出同理 123456789101112131415161718192021void change(int p,int x,int y) //change函数&#123; if(t[p].l==t[p].r&amp;&amp;t[p].l==x) &#123; t[p].ls=t[p].rs=t[p].ms=y; return; &#125; int mid=(t[p].l+t[p].r)&gt;&gt;1; if(x&lt;=mid) change(p&lt;&lt;1,x,y); else change(p&lt;&lt;1|1,x,y); //push up原先的push up是更改左右孩子的值之类的这里要进行区间的合并更改 t[p].ls=t[p&lt;&lt;1].ls; //当前的左等于左孩子的左 t[p].rs=t[p&lt;&lt;1|1].rs;//当前的右等于右孩子的右 t[p].ms=max(max(t[p&lt;&lt;1].ms,t[p&lt;&lt;1|1].ms),t[p&lt;&lt;1].rs+t[p&lt;&lt;1|1].ls);//当前的总和等于左，右，中的最大值 if(t[p&lt;&lt;1].ls==t[p&lt;&lt;1].r+1-t[p&lt;&lt;1].l)//如果左溢出加上右的左 t[p].ls+=t[p&lt;&lt;1|1].ls; if(t[p&lt;&lt;1|1].rs==t[p&lt;&lt;1|1].r+1-t[p&lt;&lt;1|1].l)//如果右溢出加上左的右 t[p].rs+=t[p&lt;&lt;1].rs;&#125; sum操作这里的sum求的是包含这个点的最大的区间长度所以如果到点了或者满了或者没有那么就返回即可然后分左右合并，如果满了就加上即可跟change的感觉差不多 1234567891011121314151617181920int sum(int p,int x)&#123; if(t[p].l==t[p].r||t[p].ms==0||t[p].ms==t[p].r+1-t[p].l) return t[p].ms; int mid=(t[p].l+t[p].r)&gt;&gt;1; if(x&lt;=mid) &#123; if(x&gt;=t[p&lt;&lt;1].r+1-t[p&lt;&lt;1].rs)//如果溢出加上右边 return sum(p&lt;&lt;1,x)+sum(p&lt;&lt;1|1,mid+1); else return sum(p&lt;&lt;1,x); &#125; else &#123; if(x&lt;=t[p&lt;&lt;1|1].l+t[p&lt;&lt;1|1].ls-1)//如果溢出加上左边 return sum(p&lt;&lt;1|1,x)+sum(p&lt;&lt;1,mid); else return sum(p&lt;&lt;1|1,x); &#125;&#125; 完整代码(hdu-1540)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;bits/stdc++.h&gt;using namespace std;struct node&#123; int l,r,ls,rs,ms;&#125;t[200005];stack&lt;int&gt; st;void build(int p,int l,int r) //递归构造树&#123; t[p].l=l;t[p].r=r; t[p].ls=t[p].rs=t[p].ms=r+1-l; if(l==r) return; int mid=(t[p].l+t[p].r)&gt;&gt;1; build(p&lt;&lt;1,l,mid); build(p&lt;&lt;1|1,mid+1,r);&#125;void change(int p,int x,int y) //change函数&#123; if(t[p].l==t[p].r&amp;&amp;t[p].l==x) &#123; t[p].ls=t[p].rs=t[p].ms=y; return; &#125; int mid=(t[p].l+t[p].r)&gt;&gt;1; if(x&lt;=mid) change(p&lt;&lt;1,x,y); else change(p&lt;&lt;1|1,x,y); //push up原先的push up是更改左右孩子的值之类的这里要进行区间的合并更改 t[p].ls=t[p&lt;&lt;1].ls; //当前的左等于左孩子的左 t[p].rs=t[p&lt;&lt;1|1].rs;//当前的右等于右孩子的右 t[p].ms=max(max(t[p&lt;&lt;1].ms,t[p&lt;&lt;1|1].ms),t[p&lt;&lt;1].rs+t[p&lt;&lt;1|1].ls);//当前的总和等于左，右，中的最大值 if(t[p&lt;&lt;1].ls==t[p&lt;&lt;1].r+1-t[p&lt;&lt;1].l)//如果左溢出加上右的左 t[p].ls+=t[p&lt;&lt;1|1].ls; if(t[p&lt;&lt;1|1].rs==t[p&lt;&lt;1|1].r+1-t[p&lt;&lt;1|1].l)//如果右溢出加上左的右 t[p].rs+=t[p&lt;&lt;1].rs;&#125;int sum(int p,int x)&#123; if(t[p].l==t[p].r||t[p].ms==0||t[p].ms==t[p].r+1-t[p].l) return t[p].ms; int mid=(t[p].l+t[p].r)&gt;&gt;1; if(x&lt;=mid) &#123; if(x&gt;=t[p&lt;&lt;1].r+1-t[p&lt;&lt;1].rs)//如果溢出加上右边 return sum(p&lt;&lt;1,x)+sum(p&lt;&lt;1|1,mid+1); else return sum(p&lt;&lt;1,x); &#125; else &#123; if(x&lt;=t[p&lt;&lt;1|1].l+t[p&lt;&lt;1|1].ls-1)//如果溢出加上左边 return sum(p&lt;&lt;1|1,x)+sum(p&lt;&lt;1,mid); else return sum(p&lt;&lt;1|1,x); &#125;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,m; while(cin&gt;&gt;n&gt;&gt;m) &#123; memset(t,0,sizeof(t)); build(1,1,n); while(m--) &#123; char c; int x; cin&gt;&gt;c; if(c=='D') &#123; cin&gt;&gt;x; change(1,x,0); st.push(x); &#125; else if(c=='R') &#123; change(1,st.top(),1); st.pop(); &#125; else &#123; cin&gt;&gt;x; cout&lt;&lt;sum(1,x)&lt;&lt;"\n"; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈理工训练赛20190310(组队赛1)]]></title>
    <url>%2F%E9%A2%98%E8%A7%A331%2F</url>
    <content type="text"><![CDATA[A Coffee Break(二分&amp;&amp;筛法)直接用素数筛法的感觉去筛选即可，就是要注意筛选的过程中如果没有恰好找到的话，那么需要二分搜索下一个位置，否则超时，然后还需要注意如果找了临近的下一个位置那么now一定要变成那个值！！！我比赛的时候因为这个wa了 代码12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;set&lt;long long&gt;st;map&lt;long long,long long&gt; ans,num;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,m,k,cnt=1; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for(int i=1;i&lt;=n;i++) cin&gt;&gt;num[i],st.insert(num[i]); while(st.size()) &#123; ans[*st.begin()]=cnt; int now=*st.begin(); st.erase(st.begin()); while(1) &#123; now+=k+1; auto it=st.lower_bound(now); if(it==st.end()) break; else &#123; ans[*it]=cnt; now=*it; st.erase(it); &#125; &#125; cnt++; &#125; cout&lt;&lt;cnt-1&lt;&lt;"\n"; for(int i=1;i&lt;=n;i++) cout&lt;&lt;ans[num[i]]&lt;&lt;" ";&#125; B Glider (二分)这个题实际上需要先把空气流层和无重力环境的层两种情况进行都先分出来然后我们会发现只需要将无重力层开始后续加上一个原先的高度即可，也不需要考虑很复杂了。最后就是二分答案，枚举各个起点然后二分无重力层最多的情况，最后答案加上初始高度即可,比赛的时候想复杂了。。。 代码123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;struct node&#123; int l,r;&#125;num[200005];int b[200005],c[200005],ans;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) cin&gt;&gt;num[i].l&gt;&gt;num[i].r; for(int i=1;i&lt;=n;i++) &#123; b[i]=num[i].r-num[i].l; c[i]=num[i].l-num[i-1].r; b[i]+=b[i-1]; c[i]+=c[i-1]; &#125; for(int i=1;i&lt;=n;i++) &#123; int pos=lower_bound(c+1,c+1+n,c[i]+m)-c; ans=max(ans,b[pos-1]-b[i-1]); &#125; cout&lt;&lt;ans+m;&#125; C Bacteria(优先队列||堆)优先队列大水题当时就是因为没敢用优先队列做，因为想到要pop两个出来感觉有点奇怪，实际上思路还是一样的。这个题大家都做出来了也不多说了 代码12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;priority_queue&lt;long long,vector&lt;long long&gt;,greater&lt;long long&gt; &gt;q;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,t,ans=0; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;t; q.push(t); &#125; while(q.size()!=1) &#123; long long p1=q.top();q.pop(); long long p2=q.top();q.pop(); if(p1==p2) q.push(p1+p2); else if((p2/p1)%2) return cout&lt;&lt;-1,0; else q.push(p1*2),q.push(p2),ans++; &#125; cout&lt;&lt;ans;&#125; D Masquerade strikes back(暴力)直接暴力出奇迹，至于如何输出看代码即可，比赛的时候没有想到真要暴力啊都 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; ans1(200005),ans2(200005);struct node&#123; int sum,id;&#125;num[200005];bool cmp(node a,node b)&#123; return a.sum&lt;b.sum;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;num[i].sum,num[i].id=i; sort(num,num+n,cmp); for(int i=0;i&lt;n;i++) &#123; int l=i,r=0; for(int j=i+1;j&lt;n;j++) if(num[j].sum==num[i].sum) r++; else break; r+=l; for(int j=1;j*j&lt;=num[i].sum;j++) &#123; if(num[i].sum%j==0) &#123; ans1[num[l].id]=j; ans2[num[l].id]=num[i].sum/j; l++; if(l&gt;r) break; if(num[i].sum!=j*j) &#123; ans1[num[l].id]=num[i].sum/j; ans2[num[l].id]=j; l++; &#125; if(l&gt;r) break; &#125; &#125; if(l&lt;=r) return cout&lt;&lt;"NO",0; i=r; &#125; cout&lt;&lt;"YES\n"; for(int i=0;i&lt;n;i++) cout&lt;&lt;ans1[i]&lt;&lt;" "&lt;&lt;ans2[i]&lt;&lt;"\n";&#125; E Painting the Fence(set)这个题真心的不好想也不好做，主要是一个离散化的过程，我们不可能用O(N*N)的时间复杂度做，如何把他们离散化呢？这里开出了set数组然后把这个数出现的位置先塞到set数组里面然后每一次染色都需要把两个位置之间的所有位置删除并且原来的数的位置也会删除。好需要加一个优化要不TLE TEST55就是如果当前删除的这个位置的数已经是被询问要染色过的话，那么他会只剩下一个终点这个时候就不要再循环暴力了，直接输出终点然后结束循环即可 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;set&lt;int&gt; st[300005];int num[300005],vis[300005],maxn,minn=int(1e9);int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,m; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;num[i],st[num[i]].insert(i),maxn=max(maxn,num[i]),minn=min(minn,num[i]); cin&gt;&gt;m; while(m--) &#123; int x; cin&gt;&gt;x; if(vis[x]||st[x].size()&lt;2) &#123; vis[x]=1; continue; &#125; int l=*(st[x].begin()); int r=*(st[x].rbegin()); for(int i=l+1;i&lt;=r-1;i++) &#123; st[num[i]].erase(i); if(vis[num[i]]&amp;&amp;st[num[i]].size()&gt;=1) &#123; i=*(st[num[i]].begin()); st[num[i]].erase(i); &#125; &#125; vis[x]=1; &#125; for(int i=minn;i&lt;=maxn;i++) if(vis[i]&amp;&amp;st[i].size()&gt;=2) &#123; int l=*(st[i].begin()); int r=*(st[i].rbegin()); for(int j=l;j&lt;=r;j++) num[j]=i; &#125; for(int i=1;i&lt;=n;i++) cout&lt;&lt;num[i]&lt;&lt;" ";&#125; F Tickets(筛法)直接预处理一次然后输出答案即可 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;int bk[66],ans[1000005];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); for(int i=0;i&lt;=999999;i++) &#123; int ttt=0; if(i&lt;1000) &#123; int te=i; int sum=0; while(te) &#123; sum+=te%10; te/=10; &#125; bk[sum]++; for(int j=0;j&lt;sum;j++) ttt+=bk[j]; ans[i]=ttt; &#125; else &#123; int te=i,cnt=0; int sum1=0,sum2=0; while(te) &#123; cnt++; if(cnt&lt;=3) sum1+=te%10; else sum2+=te%10; te/=10; &#125; bk[abs(sum1-sum2)]++; for(int j=0;j&lt;abs(sum1-sum2);j++) ttt+=bk[j]; ans[i]=ttt; &#125; //cout&lt;&lt;ans[i]&lt;&lt;"\n"; &#125; int t; cin&gt;&gt;t; while(t--) &#123; string a; cin&gt;&gt;a; stringstream tt; tt&lt;&lt;a; int te; tt&gt;&gt;te; cout&lt;&lt;ans[te]&lt;&lt;"\n"; &#125;&#125; G Tree Reconstruction(贪心&amp;&amp;思维)这个东西也是不好做，这里有一种简单的构造方法。首先判断如果最后一个节点不是最大值n的话那么肯定是不行的(这个地方确实是有点果断但是还是对的。。。)也就是说右边的节点必须得是n输入的时候否则就NO即可，然后我们升序排序把第一个最小的当成这个树的根，然后判断下一个小的数当前有两步1.如果当前的数不等于上一个数，那么把这个数也放进答案同时set维护的值去掉这个数2.否则的话看一看set顶端的最小的数是不是比当前的数小，如果是set顶端进入答案否则输出NO 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;int num[6666],ans[6666];set&lt;int&gt; st;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,x; cin&gt;&gt;n; for(int i=1;i&lt;=n-1;i++) &#123; cin&gt;&gt;num[i]&gt;&gt;x; st.insert(i); if(x!=n) return cout&lt;&lt;"NO",0; &#125; st.insert(n); sort(num+1,num+n); ans[0]=num[1]; st.erase(num[1]); for(int i=2;i&lt;=n;i++) &#123; if(num[i]!=num[i-1]) &#123; ans[i-1]=num[i]; st.erase(num[i]); &#125; else &#123; if(*st.begin()&lt;num[i]) &#123; ans[i-1]=*st.begin(); st.erase(st.begin()); &#125; else return cout&lt;&lt;"NO",0; &#125; &#125; ans[n-1]=n; cout&lt;&lt;"YES\n"; for(int i=0;i&lt;n-1;i++) cout&lt;&lt;ans[i]&lt;&lt;" "&lt;&lt;ans[i+1]&lt;&lt;"\n";&#125; H Theater Square(数学)好像都会做直接放码了 代码(昊哥版本)12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int arr[200010];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,m,x1,y1,x2,y2; cin&gt;&gt;n&gt;&gt;m&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2; int tn = x2-x1+1; n-=tn; int m1 = y1-1; int m2 = m-y2; int ans = ((m1%2)+(m2%2))*tn + (m%2)*n; if(ans%2 == 1) ans+=1; ans/=2; cout&lt;&lt;ans;&#125; I Heist(语法基础)代码123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,maxn=-1,minn=int(1e9)+100; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; int t; cin&gt;&gt;t; maxn=max(maxn,t); minn=min(minn,t); &#125; cout&lt;&lt;maxn-minn+1-n;&#125; J Buying a TV Set(数学)代码(凯哥版本)123456789101112131415161718#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; long long int a, b, x, y, t; cin &gt;&gt; a &gt;&gt; b &gt;&gt; x &gt;&gt; y; t = __gcd(x, y); x = x / t; y = y / t; long long int ans; a = a / x; b = b / y; ans = min(a, b); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; K Medians and Partition(数学&amp;&amp;规律)反正直接放lsr大佬的代码就行了12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,m,ans=0; cin&gt;&gt;n&gt;&gt;m; while(n--) &#123; int t; cin&gt;&gt;t; if(t&gt;=m) ans++; else ans--; &#125; if(ans&lt;0) ans=0; cout&lt;&lt;ans;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>补题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区间dp(1) P2858 [USACO06FEB]奶牛零食Treats for the Cows]]></title>
    <url>%2F%E7%AE%97%E6%B3%9530%2F</url>
    <content type="text"><![CDATA[胡乱分析一道区间dp的题目，大佬的算法是既然要选择左边一个或者右边的一个，那么我们可以得到一个转移方程dp[i][j]=max(dp[i+1][j],dp[i][j-1])+cha[j]-cha[i-1] 其中i,j是从i到j的最321优解显然答案就是dp[1][n] 代码1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int dp[2005][2005],num[2005],cha[2005];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;num[i],cha[i]=cha[i-1]+num[i]; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=i;j++) dp[j][i]=max(dp[j-1][i],dp[j][i+1])+cha[i]-cha[j-1]; cout&lt;&lt;dp[1][n];&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树形dp(2) P1352 没有上司的舞会]]></title>
    <url>%2F%E7%AE%97%E6%B3%9529%2F</url>
    <content type="text"><![CDATA[胡乱分析这个题目就是相对简单了，我基本想到了8成的转移方程，但是还是无奈dfs功底有点差写不出来…..转移方程就是当前选这个父亲节点或者不选这个父亲节点的问题，如果选这个父亲节点的话那么加上子节点不选的，不选那么加上子节点不选和选的最大值也就是说dp[p][0]+=max(dp[s][0],dp[s][1])dp[p][1]+=dp[s][0]其中p是父亲节点s是子节点0代表不选1代表选那么dfs即可 代码12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;int num[6666],dp[6666][6],bk[6666];vector&lt;int&gt; G[6666];void dfs(int p)&#123; dp[p][0]=0; dp[p][1]=num[p]; for(int i=0;i&lt;G[p].size();i++) &#123; dfs(G[p][i]); dp[p][0]+=max(dp[G[p][i]][0],dp[G[p][i]][1]); dp[p][1]+=dp[G[p][i]][0]; &#125;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,rt; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;num[i]; for(int i=1;i&lt;=n-1;i++) &#123; int st,ed; cin&gt;&gt;ed&gt;&gt;st; bk[ed]++; G[st].push_back(ed); &#125; for(int i=1;i&lt;=n;i++) if(!bk[i]) &#123; rt=i; break; &#125; dfs(rt); cout&lt;&lt;max(dp[rt][0],dp[rt][1]);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树形dp(1) P2015二叉苹果树]]></title>
    <url>%2F%E7%AE%97%E6%B3%9528%2F</url>
    <content type="text"><![CDATA[胡乱分析实际上树形dp就是在树上进行的dp，这个题类似于01背包的一种dp的感觉，也是树形dp的模板题第一题。状态转移是从下到上的所以是回溯的时候进行的dp转移方程dp[p][j]=max(dp[p][j],dp[p][j-k-1]+dp[to][k]+w)其中dp[i][j]代表i节点包含j条边所具有的最大权值和那么显然最终答案就是dp[1][q]为什么是j-k-1因为要保证节点之间相互连接，剩下的就是从下向上dp了还有就是dfs函数计算的是当前节点下有多少的边，dp的时候不能分的边比原本包含的边要多吧 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;int n,m;struct node&#123; int to,sum;&#125;;vector&lt;node&gt; G[105];int dp[105][105],num[105];int dfs(int now,int fa)&#123; for(int i=0;i&lt;G[now].size();i++) if(G[now][i].to!=fa) num[now]+=dfs(G[now][i].to,now); if(!num[now]) return 1; else return num[now]+1;&#125;void solve(int now,int fa)&#123; for(int i=0;i&lt;G[now].size();i++) if(G[now][i].to!=fa) &#123; solve(G[now][i].to,now); for(int j=m;j;j--) for(int k=0;k&lt;j&amp;&amp;k&lt;=num[now];k++) dp[now][j]=max(dp[now][j],dp[now][j-k-1]+dp[G[now][i].to][k]+G[now][i].sum); &#125;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n-1;i++) &#123; int st,ed,sum; cin&gt;&gt;st&gt;&gt;ed&gt;&gt;sum; G[st].push_back((node)&#123;ed,sum&#125;); G[ed].push_back((node)&#123;st,sum&#125;); &#125; dfs(1,1); solve(1,1); cout&lt;&lt;dp[1][m];&#125; 尝试后发现不加dfs也是对的 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;int n,m;struct node&#123; int to,sum;&#125;;vector&lt;node&gt; G[105];int dp[105][105],num[105];void solve(int now,int fa)&#123; for(int i=0;i&lt;G[now].size();i++) if(G[now][i].to!=fa) &#123; solve(G[now][i].to,now); for(int j=m;j;j--) for(int k=0;k&lt;j;k++) dp[now][j]=max(dp[now][j],dp[now][j-k-1]+dp[G[now][i].to][k]+G[now][i].sum); &#125;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n-1;i++) &#123; int st,ed,sum; cin&gt;&gt;st&gt;&gt;ed&gt;&gt;sum; G[st].push_back((node)&#123;ed,sum&#125;); G[ed].push_back((node)&#123;st,sum&#125;); &#125; solve(1,1); cout&lt;&lt;dp[1][m];&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈理工训练赛20190304(简略题解)]]></title>
    <url>%2F%E9%A2%98%E8%A7%A327%2F</url>
    <content type="text"><![CDATA[A - Watto and Mechanism(trie&amp;&amp;dfs)胡乱分析先创建字典树，然后每个rt对应的字母一个一个dfs枚举，最终得到答案 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std;string a;int tot,trie[666666][6],bk[666666],len,f;void insert(string a)&#123; int rt=0; for(int i=0;i&lt;a.size();i++) &#123; int id=a[i]-'a'; if(!trie[rt][id]) trie[rt][id]=++tot; rt=trie[rt][id]; &#125; bk[rt]=1;&#125;int dfs(int pos,int rt)&#123; if(pos==len) &#123; if(bk[rt]&amp;&amp;!f) return 1; else return 0; &#125; int id=a[pos]-'a'; for(int i=0;i&lt;3;i++) &#123; if(trie[rt][i]) &#123; if(i==id) &#123; if(dfs(pos+1,trie[rt][i])) return 1; &#125; else if(f) &#123; f=0; if(dfs(pos+1,trie[rt][i])) return 1; f=1; &#125; &#125; &#125; return 0;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,m; cin&gt;&gt;n&gt;&gt;m; while(n--) &#123; cin&gt;&gt;a; insert(a); &#125; while(m--) &#123; cin&gt;&gt;a; f=1; len=a.size(); if(dfs(0,0)) cout&lt;&lt;"YES\n"; else cout&lt;&lt;"NO\n"; &#125;&#125; B - Infinite InversionsC - Pashmak and Parmida’s problem (逆序对)胡乱分析树状数组求逆序对，需要离散化一下这个式子然后倒着装，至于怎么装我也不知道题解怎么想出来的，不过确实挺巧妙的 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;int n,c[1000005],pre[1000005],ed[1000005],num[1000005];unordered_map&lt;int,int&gt; bk1,bk2;int lowb(int x)&#123; return x&amp;(-x);&#125;void add(int x)&#123; for(int i=x;i&lt;=n;i+=lowb(i)) c[i]++;&#125;int sum(int x)&#123; int ans=0; for(int i=x;i;i-=lowb(i)) ans+=c[i]; return ans;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); long long ans=0; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;num[i]; bk1[num[i]]++; pre[i]=bk1[num[i]]; &#125; for(int i=n;i;i--) &#123; bk2[num[i]]++; ed[i]=bk2[num[i]]; &#125; for(int i=n;i;i--) &#123; ans+=sum(pre[i]-1); add(ed[i]); &#125; cout&lt;&lt;ans;&#125; D - Balanced Lineup (RMQ)胡乱分析ST表和线段树都可过，ST表快一点 代码(ST表)123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int ans1[666666][25],ans2[666666][25];int sum1(int l,int r)&#123; int k=log2(r-l+1); return max(ans1[l][k],ans1[r-(1&lt;&lt;k)+1][k]);&#125;int sum2(int l,int r)&#123; int k=log2(r-l+1); return min(ans2[l][k],ans2[r-(1&lt;&lt;k)+1][k]);&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) cin&gt;&gt;ans1[i][0],ans2[i][0]=ans1[i][0]; for(int j=1;j&lt;=21;j++) for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;i++) ans1[i][j]=max(ans1[i][j-1],ans1[i+(1&lt;&lt;j-1)][j-1]); for(int j=1;j&lt;=21;j++) for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;i++) ans2[i][j]=min(ans2[i][j-1],ans2[i+(1&lt;&lt;j-1)][j-1]); while(m--) &#123; int l,r; cin&gt;&gt;l&gt;&gt;r; cout&lt;&lt;sum1(l,r)-sum2(l,r)&lt;&lt;"\n"; &#125;&#125; 代码(线段树)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;using namespace std;struct node&#123; int l,r,maxn,minn;&#125;t[666666];int num[666666];void build(int p,int l,int r)&#123; t[p].l=l;t[p].r=r; if(l==r) &#123; t[p].maxn=num[l]; t[p].minn=num[l]; return; &#125; int mid=(t[p].l+t[p].r)&gt;&gt;1; build(2*p,l,mid); build(2*p+1,mid+1,r); t[p].maxn=max(t[2*p].maxn,t[2*p+1].maxn); t[p].minn=min(t[2*p].minn,t[2*p+1].minn);&#125;int Max(int p,int x,int y)&#123; if(t[p].l&gt;=x&amp;&amp;t[p].r&lt;=y) return t[p].maxn; int mid=(t[p].l+t[p].r)&gt;&gt;1; int maxn=-1; if(x&lt;=mid) maxn=max(maxn,Max(2*p,x,y)); if(y&gt;mid) maxn=max(maxn,Max(2*p+1,x,y)); return maxn;&#125;int Min(int p,int x,int y)&#123; if(t[p].l&gt;=x&amp;&amp;t[p].r&lt;=y) return t[p].minn; int mid=(t[p].l+t[p].r)&gt;&gt;1; int minn=int(1e9)+7; if(x&lt;=mid) minn=min(minn,Min(2*p,x,y)); if(y&gt;mid) minn=min(minn,Min(2*p+1,x,y)); return minn;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) cin&gt;&gt;num[i]; build(1,1,n); while(m--) &#123; int l,r; cin&gt;&gt;l&gt;&gt;r; cout&lt;&lt;Max(1,l,r)-Min(1,l,r)&lt;&lt;"\n"; &#125;&#125; E - Snowflake Snow Snowflakes(哈希)胡乱分析这里用哈希，按照字符串模大质数加和的哈希，因为我们要把可能相同的放到一起去寻找，所以这样可以建立一个哈希表然后把可能相同的单独拿出来进行旋转比较的哈希，这里开了读入挂能够快一点读入，这题常数有点大 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;using namespace std;vector&lt;int&gt; hs[1000006];int num[200005][10];int mod=999983;typedef long long ll;inline ll read()&#123; ll x=0,f=1; char c=getchar(); for(;!isdigit(c);c=getchar()) if(c=='-') f=0; for(;isdigit(c);c=getchar()) x=(x&lt;&lt;1)+(x&lt;&lt;3)+c-'0'; return f?x:-x;&#125;int check(int a,int b)&#123; for(int i=0;i&lt;6;i++) &#123; if(num[a][0]==num[b][i]&amp;&amp;num[a][1]==num[b][(i+1)%6]&amp;&amp;num[a][2]==num[b][(i+2)%6]&amp;&amp;num[a][3]==num[b][(i+3)%6]&amp;&amp;num[a][4]==num[b][(i+4)%6]&amp;&amp;num[a][5]==num[b][(i+5)%6]) return 1; if(num[a][0]==num[b][i]&amp;&amp;num[a][1]==num[b][(i+5)%6]&amp;&amp;num[a][2]==num[b][(i+4)%6]&amp;&amp;num[a][3]==num[b][(i+3)%6]&amp;&amp;num[a][4]==num[b][(i+2)%6]&amp;&amp;num[a][5]==num[b][(i+1)%6]) return 1; &#125; return 0;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n; n=read(); for(int i=1;i&lt;=n;i++) &#123; long long ans=0; for(int j=0;j&lt;6;j++) &#123; num[i][j]=read(); ans=(ans%mod+num[i][j]%mod)%mod; &#125; int len=hs[ans].size(); if(len==0) hs[ans].push_back(i); else &#123; for(int j=0;j&lt;len;j++) &#123; if(check(i,hs[ans][j])) return cout&lt;&lt;"Twin snowflakes found.",0; &#125; hs[ans].push_back(i); &#125; &#125; cout&lt;&lt;"No two snowflakes are alike.";&#125; F - 敌兵布阵 (树状数组)胡乱分析树状数组和线段树都可过，但是树状数组能够写少一点，对于这种单点修改的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;long long n,ans[50005];int lowb(int x)&#123; return x&amp;(-x);&#125;void add(int num,int sum)&#123; for(int i=num;i&lt;=n;i+=lowb(i)) ans[i]+=sum;&#125;int sum(int x)&#123; long long sum=0; for(int i=x;i;i-=lowb(i)) sum+=ans[i]; return sum;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t,cnt=0; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n; memset(ans,0,sizeof(ans)); for(int i=1;i&lt;=n;i++) &#123; int te; cin&gt;&gt;te; add(i,te); &#125; string a; cout&lt;&lt;"Case "&lt;&lt;++cnt&lt;&lt;":\n"; while(cin&gt;&gt;a) &#123; if(a[0]=='Q') &#123; int l,r; cin&gt;&gt;l&gt;&gt;r; cout&lt;&lt;sum(r)-sum(l-1)&lt;&lt;"\n"; &#125; else if(a[0]=='A') &#123; int num,sum; cin&gt;&gt;num&gt;&gt;sum; add(num,sum); &#125; else if(a[0]=='S') &#123; int num,sum; cin&gt;&gt;num&gt;&gt;sum; add(num,-sum); &#125; else if(a[0]=='E') break; &#125; &#125;&#125; G - Oulipo(KMP)胡乱分析裸题KMP 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int nex[1000100];char a[1000100],b[1000100];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t; cin&gt;&gt;t; while(t--) &#123; int j=0,sum=0; cin&gt;&gt;a+1&gt;&gt;b+1; int lena=strlen(a+1); int lenb=strlen(b+1); memset(nex,0,sizeof(nex)); for(int i=2;i&lt;=lena;i++) &#123; while(j&amp;&amp;a[i]!=a[j+1]) j=nex[j]; if(a[i]==a[j+1]) j++; nex[i]=j; &#125; j=0; for(int i=1;i&lt;=lenb;i++) &#123; while(j&amp;&amp;b[i]!=a[j+1]) j=nex[j]; if(b[i]==a[j+1]) j++; if(j==lena) sum++,j=nex[j]; &#125; cout&lt;&lt;sum&lt;&lt;"\n"; &#125;&#125; H - Power Strings(next数组应用)胡乱分析记住len|(len-next[len])时len/(len-next[len])能求最小长度循环串的循环长度 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int nex[1000100];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); string a; while(cin&gt;&gt;a) &#123; a.insert(0,"#"); if(a[1]=='.') break; int j=0; int len=a.size()-1; if(len==0) &#123; cout&lt;&lt;0&lt;&lt;"\n"; continue; &#125; for(int i=2;i&lt;=len;i++) &#123; while(j&amp;&amp;a[i]!=a[j+1]) j=nex[j]; if(a[i]==a[j+1]) j++; nex[i]=j; &#125; if(len%(len-nex[len])==0) cout&lt;&lt;len/(len-nex[len])&lt;&lt;"\n"; else cout&lt;&lt;1&lt;&lt;"\n"; &#125;&#125; I - Period (next数组应用)胡乱分析同上一个题，不过就是最后求循环次数变成了边线性扫描边求 代码12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int nex[1000100];char a[1000100],b[1000100];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t,cnt=0; while(cin&gt;&gt;t) &#123; if(t==0) break; cin&gt;&gt;a+1; int len=strlen(a+1); memset(nex,0,sizeof(nex)); int j=0; for(int i=2;i&lt;=len;i++) &#123; while(j&amp;&amp;a[i]!=a[j+1]) j=nex[j]; if(a[i]==a[j+1]) j++; nex[i]=j; &#125; cout&lt;&lt;"Test case #"&lt;&lt;++cnt&lt;&lt;"\n"; for(int i=2;i&lt;=len;i++) if(i%(i-nex[i])==0&amp;&amp;i/(i-nex[i])&gt;1) cout&lt;&lt;i&lt;&lt;" "&lt;&lt;i/(i-nex[i])&lt;&lt;"\n"; cout&lt;&lt;"\n"; &#125;&#125; J - Hat’s Words (trie)胡乱分析这题网上说最多每个单词只有20个字符所以map可以水过，但是正解还是trie 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;string st[66666];int bk[6666666],tot,trie[66666][66],p;void insert(string a)&#123; int rt=0; for(int i=0;i&lt;a.size();i++) &#123; int id=a[i]-'a'; if(!trie[rt][id]) trie[rt][id]=++tot; rt=trie[rt][id]; &#125; bk[rt]=1;&#125;int search(string a)&#123; int rt=0; for(int i=0;i&lt;a.size();i++) &#123; int id=a[i]-'a'; if(!trie[rt][id]) return 0; rt=trie[rt][id]; &#125; return bk[rt];&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); string a; while(cin&gt;&gt;a) st[p++]=a,insert(a); for(int i=0;i&lt;p;i++) for(int j=0;j&lt;st[i].size();j++) &#123; string a=st[i].substr(0,j); string b=st[i].substr(j,st[i].size()-1); if(search(a)&amp;&amp;search(b)) &#123; cout&lt;&lt;st[i]&lt;&lt;"\n"; break; &#125; &#125;&#125; K - Black Box (堆)胡乱分析创建一个大根堆和一个小根堆，大根堆维护前k-1个的最小值 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int num[666666];priority_queue&lt;int&gt; big;priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;small;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) cin&gt;&gt;num[i]; int now=1; while(m--) &#123; int t; cin&gt;&gt;t; while(now&lt;=t) &#123; small.push(num[now]); if(!big.empty()&amp;&amp;small.top()&lt;big.top()) &#123; int t1=big.top(); int t2=small.top(); big.pop(); small.pop(); big.push(t2); small.push(t1); &#125; now++; &#125; cout&lt;&lt;small.top()&lt;&lt;"\n"; big.push(small.top()); small.pop(); &#125;&#125; L - 搬果子 (堆)胡乱分析放进去自己排序这样快，注意直接排序求解会可能合并的时候合出来一个大的还需要再排序，所以直接用堆即可 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; while(cin&gt;&gt;n) &#123; priority_queue&lt;int&gt; q; while(n--) &#123; int te; cin&gt;&gt;te; q.push(-te); &#125; int sum=0; while(q.size()&gt;1) &#123; int p1=q.top(); q.pop(); int p2=q.top(); q.pop(); sum+=-(p1+p2); q.push(p1+p2); //cout&lt;&lt;sum&lt;&lt;"\n"; &#125; cout&lt;&lt;sum&lt;&lt;"\n"; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>补题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树基础求和与修改]]></title>
    <url>%2F%E7%AE%97%E6%B3%9526%2F</url>
    <content type="text"><![CDATA[胡乱分析说到线段树实际上还是一个具有叫做lazy tag的完全二叉树 分布操作建树建树操作需要知道一个就是当前p的左儿子是2p右儿子是2p+1然后我们递归建树即可，回溯的时候更新每个值所以代码就比较清晰了，如果当前l=r的话那么我们就把这个叶子节点赋值然后向上回溯即可 12345678910111213void build(int p,int l,int r)&#123; t[p].l=l;t[p].r=r; if(l==r) &#123; t[p].sum=num[l]; return; &#125; int mid=(l+r)&gt;&gt;1; build(2*p,l,mid); build(2*p+1,mid+1,r); t[p].sum=t[2*p].sum+t[2*p+1].sum;&#125; lazy tag下放lazy tag在这里是记录区间总共更改了多少，下放的时候要注意更改左右儿子的值并且把左右儿子的lazy tag更新，自己的lazy tag清除 1234567891011void lazy(int p)&#123; if(t[p].tag) &#123; t[2*p].sum+=t[p].tag*(t[2*p].r+1-t[2*p].l); t[2*p+1].sum+=t[p].tag*(t[2*p+1].r+1-t[2*p+1].l); t[2*p].tag+=t[p].tag; t[2*p+1].tag+=t[p].tag; t[p].tag=0; &#125;&#125; 更改操作更改是把父节点对应的子节点的个数乘以修改的值，因为每个节点都加上一个数，所以一次把加和给父节点，并且给父节点打上lazy tag,如果修改的区间并不覆盖父节点所管理的范围，那么下放lazy tag并且递归更改其他区间，最后回溯赋值 12345678910111213141516void change(int p,int x,int y,int z)&#123; if(t[p].l&gt;=x&amp;&amp;t[p].r&lt;=y) &#123; t[p].sum+=1LL*z*(t[p].r+1-t[p].l); t[p].tag+=z; return; &#125; lazy(p); int mid=(t[p].r+t[p].l)&gt;&gt;1; if(x&lt;=mid) change(p*2,x,y,z); if(y&gt;mid) change(p*2+1,x,y,z); t[p].sum=t[2*p].sum+t[2*p+1].sum;&#125; 查询查询需要看当前是不是已经区间覆盖了，如果是那么返回当前的区间的值，否则还是下放lazy tag进行递归寻找 12345678910111213long long sum(int p,int x,int y)&#123; if(t[p].l&gt;=x&amp;&amp;t[p].r&lt;=y) return t[p].sum; lazy(p); int mid=(t[p].r+t[p].l)&gt;&gt;1; long long ans=0; if(x&lt;=mid) ans+=sum(2*p,x,y); if(y&gt;mid) ans+=sum(2*p+1,x,y); return ans;&#125; 完整模板(洛谷P3372 【模板】线段树 1)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;using namespace std;struct node&#123; long long l,r,sum,tag;&#125;t[666666];long long num[666666];void build(int p,int l,int r)&#123; t[p].l=l;t[p].r=r; if(l==r) &#123; t[p].sum=num[l]; return; &#125; int mid=(l+r)&gt;&gt;1; build(2*p,l,mid); build(2*p+1,mid+1,r); t[p].sum=t[2*p].sum+t[2*p+1].sum;&#125;void lazy(int p)&#123; if(t[p].tag) &#123; t[2*p].sum+=t[p].tag*(t[2*p].r+1-t[2*p].l); t[2*p+1].sum+=t[p].tag*(t[2*p+1].r+1-t[2*p+1].l); t[2*p].tag+=t[p].tag; t[2*p+1].tag+=t[p].tag; t[p].tag=0; &#125;&#125;void change(int p,int x,int y,int z)&#123; if(t[p].l&gt;=x&amp;&amp;t[p].r&lt;=y) &#123; t[p].sum+=1LL*z*(t[p].r+1-t[p].l); t[p].tag+=z; return; &#125; lazy(p); int mid=(t[p].r+t[p].l)&gt;&gt;1; if(x&lt;=mid) change(p*2,x,y,z); if(y&gt;mid) change(p*2+1,x,y,z); t[p].sum=t[2*p].sum+t[2*p+1].sum;&#125;long long sum(int p,int x,int y)&#123; if(t[p].l&gt;=x&amp;&amp;t[p].r&lt;=y) return t[p].sum; lazy(p); int mid=(t[p].r+t[p].l)&gt;&gt;1; long long ans=0; if(x&lt;=mid) ans+=sum(2*p,x,y); if(y&gt;mid) ans+=sum(2*p+1,x,y); return ans;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) cin&gt;&gt;num[i]; build(1,1,n); while(m--) &#123; int p,x,y,z; cin&gt;&gt;p; if(p==1) &#123; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; change(1,x,y,z); &#125; else &#123; cin&gt;&gt;x&gt;&gt;y; cout&lt;&lt;sum(1,x,y)&lt;&lt;"\n"; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论编程实验]]></title>
    <url>%2F%E8%A1%A5%E9%A2%9825%2F</url>
    <content type="text"><![CDATA[A - 素数筛埃式筛法直接能够水过，注意一下从小开始枚举就行 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;int bk[1000005];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); for(int i=2;i*i&lt;=1000000;i++) if(!bk[i]) for(int j=i+i;j&lt;=1000000;j+=i) bk[j]=1; int n; while(cin&gt;&gt;n) &#123; if(n==0) break; for(int i=2;i;i++) if(!bk[n-i]&amp;&amp;!bk[i]) &#123; cout&lt;&lt;n&lt;&lt;" = "&lt;&lt;i&lt;&lt;" + "&lt;&lt;n-i&lt;&lt;"\n"; break; &#125; &#125;&#125; B - 素数筛(403了….)C - 素数筛还是用埃式筛法筛选出来之后用一维前缀和记录这个区间内的答案然后结果就是ans[r]-ans[l-1] 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;int bk[1000005],ans[1000005];int check(int x)&#123; long long sum=0; int p=x; while(p) &#123; sum+=p%10; p/=10; &#125; if(!bk[x]&amp;&amp;!bk[sum]) return 1; else return 0;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); for(int i=2;i*i&lt;=1000000;i++) if(!bk[i]) for(int j=i+i;j&lt;=1000000;j+=i) bk[j]=1; for(int i=2;i&lt;=1000000;i++) &#123; int sum=0; if(check(i)) sum=1; ans[i]=ans[i-1]+sum; &#125; int t; cin&gt;&gt;t; while(t--) &#123; int l,r; cin&gt;&gt;l&gt;&gt;r; cout&lt;&lt;ans[r]-ans[l-1]&lt;&lt;"\n"; &#125;&#125; D - 素数筛埃式筛法朴素的寻找左右边界即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;using namespace std;int bk[1299715],ans[1299715];int check(int x)&#123; long long sum=0; int p=x; while(p) &#123; sum+=p%10; p/=10; &#125; if(!bk[x]&amp;&amp;!bk[sum]) return 1; else return 0;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); for(int i=2;i*i&lt;=1299710;i++) if(!bk[i]) for(int j=i+i;j&lt;=1299710;j+=i) bk[j]=1; int n; while(cin&gt;&gt;n) &#123; if(n==0) break; if(!bk[n]) cout&lt;&lt;0&lt;&lt;"\n"; else &#123; long long sum=0; for(int i=n+1;;i++) &#123; sum++; if(!bk[i]) break; &#125; for(int i=n-1;i&gt;=2;i--) &#123; sum++; if(!bk[i]) break; &#125; cout&lt;&lt;sum&lt;&lt;"\n"; &#125; &#125;&#125; E - 欧几里得算法这里注意一个结论就是gcd(a,b)与gcd(a+tb,b)的互质性相同，也就是说如果a,b互质那么a+tb与b互质，所以我们可以用已经知道的小的k-th互质数推出大的1e9-th的互质数 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int ans[1000005];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,k; while(cin&gt;&gt;n&gt;&gt;k) &#123; int p=0; for(int i=1;i&lt;=n;i++) if(__gcd(i,n)==1) ans[++p]=i; cout&lt;&lt;ans[(k-1)%p+1]+(k-1)/p*n&lt;&lt;"\n"; &#125;&#125; F - 同余定理快速幂取余板子，余数原理的应用(a+b+c)%d=a%d+b%d+c%d,(abc)%d=a%dxb%dxc%d 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;long long qpow(int a,int b,int mod)&#123; long long ans=1,base=a; while(b) &#123; if(b&amp;1) ans=ans*base%mod; base=base*base%mod; b&gt;&gt;=1; &#125; return ans;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t; cin&gt;&gt;t; while(t--) &#123; int mod,n; long long sum=0; cin&gt;&gt;mod&gt;&gt;n; while(n--) &#123; int a,b; cin&gt;&gt;a&gt;&gt;b; sum+=qpow(a,b,mod); sum%=mod; &#125; cout&lt;&lt;sum%mod&lt;&lt;"\n"; &#125;&#125; 下面的题都是用了拓展欧几里得求一元线性同余方程的解所以我们需要先了解一下什么是拓展欧几里得算法可以看我的另一篇博文拓展欧几里得算法求线性同余方程 G - 一元线性同余方程计算线性同余方程最小的整数解，首先要找到a,b,c对应的位置，然后套用最小整数解的公式即可，中间的判断也是必不可少 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;typedef long long ll;void gcd(ll a,ll b,ll &amp;d,ll &amp;x,ll &amp;y)&#123; if(!b) d=a,x=1,y=0; else gcd(b,a%b,d,y,x),y-=x*(a/b);&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); ll A,B,C,k,x,y,d; while(cin&gt;&gt;A&gt;&gt;B&gt;&gt;C&gt;&gt;k) &#123; if(A==0&amp;&amp;B==0&amp;&amp;C==0&amp;&amp;k==0) break; ll a=C; ll b=1LL&lt;&lt;k; ll c=B-A; gcd(a,b,d,x,y); if(c%d) cout&lt;&lt;"FOREVER\n"; else &#123; x=(x*(c/d))%b; ll b1=b/d; cout&lt;&lt;(x%b1+b1)%b1&lt;&lt;"\n"; &#125; &#125;&#125; H - 拓展欧几里得算法求逆元跟上面一样甚至还比上面的简单，注意如果逆元是0那么输出为1 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;void gcd(int a,int b,int &amp;d,int &amp;x,int &amp;y)&#123; if(!b) d=a,x=1,y=0; else gcd(b,a%b,d,y,x),y-=x*(a/b);&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t; cin&gt;&gt;t; while(t--) &#123; int a,b,c=1,x,y,d; cin&gt;&gt;a&gt;&gt;b; gcd(a,b,d,x,y); if(c%d) cout&lt;&lt;"Not Exist\n"; else &#123; x=(x*(c/d))%b; int b1=b/d; cout&lt;&lt;(!((x%b1+b1)%b1)?1:(x%b1+b1)%b1)&lt;&lt;"\n"; &#125; &#125;&#125;]]></content>
      <categories>
        <category>补题</category>
      </categories>
      <tags>
        <tag>每周作业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拓展欧几里得算法求线性同余方程]]></title>
    <url>%2F%E7%AE%97%E6%B3%9524%2F</url>
    <content type="text"><![CDATA[欧几里得算法简述首先说一下欧几里得算法怎么回事gcd(a,b)=gcd(b,a%b)这就是欧几里得算法然后还需要记住一个结论gcd(a,b)与gcd(a+bt,b)互质属性相同，也就是a,b互质那么a+bt与b也互质其中t是一个任意的整数 代码1234int gcd(int a,int b)&#123; return !b?0:gcd(b,a%b);&#125; 拓展欧几里得算法简述首先说一下线性同余方程ax≡c(mod b)是什么意思？线性同余顾名思义就是左边与右边余数相同也就是说(ax)%b=c%b也就是说(ax-c)%b=0也就是说(ax-c)=by所以ax+by=m这也就是一个二元一次方程因为只有一个式子所以他的解是无穷多个的拓展欧几里得算法算的就是ax+by=gcd(a,b)时候的x和y是多少说是拓展欧几里得算法，那么其中肯定包含求gcd的一般欧几里得算法 代码1234567void exgcd(int a,int b,int &amp;d,int &amp;x,int &amp;y)&#123; if(!b) d=a,x=1,y=0; else exgcd(b,a%b,d,y,x),y-=x*(a/b);&#125; 唯一需要记忆的地方就是y-=x*(a/b);其中d是gcd(a,b) x,y是求解的值 拓展这样我们把特殊的ax+by=gcd(a,b)拓展到ax+by=c那么我们就可以得到如果c|gcd(a,b)那么存在整数解否则不存在整数解这样我们还需要知道一个延伸的最小整数解的公式为:x0=(x0*(c/d))%b这里先c/d比较好保证不要爆表b1=b/dx=(x0%b1+b1)%b1]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性素数筛法(欧拉筛法)]]></title>
    <url>%2F%E7%AE%97%E6%B3%9523%2F</url>
    <content type="text"><![CDATA[概括首先说一下欧拉筛法的时间复杂度为O(N)，这也是目前来说我知道的最快的素数筛法了，而且他是把素数都筛选了出来，跟埃式筛法不一样的是，每个素数都加进了素数表里面，埃式筛法紧紧是一个判断 思路既然是O(N)的算法那么肯定是要线性走一遍2到maxn这个闭区间的，然后类似于埃式筛法如果当前的数没有被打上标记，那么加入到素数表里面，然后也类似于埃式筛法进行一波枚举，这里不同的是欧拉筛法是把当前的数与之前的素数表里面的数进行相乘而埃式筛法是直接把所有的2倍3倍4倍…都筛选了出来然后最最重要的优化是如果当前的i能够整除当前枚举的这个素数，那么就结束内层的枚举倍数算法这样能够保证每个合数都被筛选了一遍因为要保证当前的素数不会被之后的筛选到！！！ 代码筛选前100个素数，使用欧拉筛法 #include &lt;bits/stdc++.h&gt; using namespace std; int bk[1000005],prime[1000005]; int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int cnt=0; for(int i=2;i&lt;=1000000;i++) { if(!bk[i]) prime[++cnt]=i; for(int j=1;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=1000000;j++) { bk[i*prime[j]]=1; if(i%prime[j]==0) break; } } for(int i=1;i&lt;=100;i++) cout&lt;&lt;prime[i]&lt;&lt;" "; }]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorizedajax1%2F</url>
    <content type="text"><![CDATA[#ajax_test { font-size: 36px; font-align: center; color: red; background-color: purple; } jQuery的load太好用了！！！]]></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery ajax测试]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF22%2F</url>
    <content type="text"><![CDATA[现在完全是bug……我都服了本地完美运行的代码，点击即可出现刷新的啊 实例部分 $(document).ready(function(){ $("#btn1").click(function(){ $('#aaaa').load('https://www.baccano.fun/uncategorizedajax1/ #ajax_test'); }) }) 请点击下面的按钮，通过 jQuery AJAX 改变这段文本。 获得外部的内容 L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/assets/hibiki.model.json"},"display":{"position":"left","width":100,"height":300},"mobile":{"show":false},"log":false,"tagMode":false}); # 代码部分 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src="http://ajax.aspnetcdn.com/ajax/jQuery/jquery-1.8.0.js"&gt;&lt;/script&gt;&lt;script&gt;$(document).ready(function()&#123; $("#btn1").click(function()&#123; $('#aaaa').load('https://www.baccano.fun/uncategorizedajax1/ #ajax_test'); &#125;)&#125;)&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h3 id="aaaa"&gt;请点击下面的按钮，通过 jQuery AJAX 改变这段文本。&lt;/h3&gt;&lt;button id="btn1" type="button"&gt;获得外部的内容&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年春季个人训练赛第一场（新生场）(补题题解)]]></title>
    <url>%2F%E4%B8%AD%E7%9F%B3%E6%B2%B9%E8%AE%AD%E7%BB%83%E8%B5%9B21%2F</url>
    <content type="text"><![CDATA[C 海港胡乱分析上来就看错了以为k的总和有3e5一想n都有1e5那不输入都超时直接不会了…这个题要做也是枚举人，定义一个队列，队列放入结构体，结构体有时间和人的id，这样每次枚举的时候看看队首的时间是不是已经不在这一天范围内了，那么就要队首出对，如果队首先减去一人没有人的话，答案也要减一 代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;struct node&#123; int t,id;&#125;;int ans[666666];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,sum=0; cin&gt;&gt;n; queue&lt;node&gt; q; while(n--) &#123; int t,k; cin&gt;&gt;t&gt;&gt;k; while(k--) &#123; int id; cin&gt;&gt;id; q.push((node)&#123;t,id&#125;); if(!ans[id]) sum++; ans[id]++; &#125; while(t-q.front().t&gt;=86400) &#123; ans[q.front().id]--; if(!ans[q.front().id]) sum--; q.pop(); &#125; cout&lt;&lt;sum&lt;&lt;"\n"; &#125;&#125;]]></content>
      <categories>
        <category>中石油训练赛</category>
      </categories>
      <tags>
        <tag>补题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[家乡的发展历程]]></title>
    <url>%2F%E8%AE%B0%E5%BD%9520%2F</url>
    <content type="text"><![CDATA[转载自百度 济南市，简称“济”，别称“泉城”，是山东省省会、 [1] 全国十五个副省级城市之一，环渤海地区南翼的中心城市，山东省的政治、文化、教育、交通和科技中心。 [2] 中国人民解放军北部战区陆军机关驻地 [3] ，山东半岛城市群和济南都市圈核心城市、新一线城市。 济南因境内泉水众多，拥有“七十二名泉”，被称为“泉城”，素有“四面荷花三面柳，一城山色半城湖”的美誉，济南八景闻名于世，是拥有“山、泉、湖、河、城”独特风貌的旅游城市，是国家历史文化名城、首批中国优秀旅游城市，史前文化——龙山文化的发祥地之一。 济南北连首都经济圈，南接长三角经济圈，东西连通山东半岛与华中地区，是环渤海经济区和京沪经济轴上的重要交汇点，环渤海地区和黄河中下游地区中心城市之一。济南已成功举办亚洲杯、全运会、中国国际园林花卉博览会、中国艺术节等多项国际和国家级盛会，2015年第22届国际历史科学大会也在济南成功举办，标志着这项世界盛会创办一个多世纪后首次走进亚洲。2016年中国绿公司年会 [4] 、2017年第五届世界摄影大会在济南开幕 [5] 。 2016年12月7日，济南市被国务院列为第三批国家新型城镇化综合试点地区 [6] 。2017年中国百强城市排行榜排19位。 [7-8] 2018年1月，国务院正式批复《山东新旧动能转换综合试验区建设总体方案》，支持济南建设国家新旧动能转换先行区。 [9-]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用jQuery实现简易钢琴按键博客栏底部小插件]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF19%2F</url>
    <content type="text"><![CDATA[源代码html部分123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en" dir="ltr"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;简易发声器&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 class="piano"&gt;---简易的七键钢琴插件---&lt;/h1&gt; &lt;p class="piano"&gt;可以使用鼠标点击琴键也可以使用主键盘1-7或者小键盘的1-7来操作&lt;/p&gt; &lt;h1 class="piano_start"&gt;那么现在开始吧&lt;/h1&gt; &lt;ul class="piano"&gt; &lt;li class="piano" id="pone"&gt;1&lt;/li&gt; &lt;li class="piano" id="ptwo" &gt;2&lt;/li&gt; &lt;li class="piano" id="pthree"&gt;3&lt;/li&gt; &lt;li class="piano" id="pfour"&gt;4&lt;/li&gt; &lt;li class="piano" id="pfive"&gt;5&lt;/li&gt; &lt;li class="piano" id="psix"&gt;6&lt;/li&gt; &lt;li class="piano" id="pseven"&gt;7&lt;/li&gt; &lt;/ul&gt; &lt;audio id="sound1" src="/audio/b0.mp3"&gt;&lt;/audio&gt; &lt;audio id="sound2" src="/audio/b1.mp3"&gt;&lt;/audio&gt; &lt;audio id="sound3" src="/audio/b2.mp3"&gt;&lt;/audio&gt; &lt;audio id="sound4" src="/audio/b3.mp3"&gt;&lt;/audio&gt; &lt;audio id="sound5" src="/audio/b4.mp3"&gt;&lt;/audio&gt; &lt;audio id="sound6" src="/audio/b5.mp3"&gt;&lt;/audio&gt; &lt;audio id="sound7" src="/audio/b6.mp3"&gt;&lt;/audio&gt; &lt;script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="/js/src/piano.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; CSS部分12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667li.piano&#123; display: inline-block; width: 90px; height: 400px; position: relative; border-style: outset; border-width: thick;&#125;#pone&#123; left:10px; top:0px; background-color: white;&#125;#ptwo&#123; left:10px; top:0px; background-color: yellow;&#125;#pthree&#123; left:10px; top:0px; background-color: green;&#125;#pfour&#123; left:10px; top:0px; background-color: blue;&#125;#pfive&#123; left:10px; top:0px; background-color: orange;&#125;#psix&#123; left:10px; top:0px; background-color: red;&#125;#pseven&#123; left:10px; top:0px; background-color: black;&#125;h1.piano&#123; text-align: center;&#125;p.piano&#123; text-align: center;&#125;h1.piano_start&#123; background-color: purple; color: white; width:50%; text-align: center; margin: 0px auto;&#125; JavaScript部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421$('ul.piano').hide();$('h1.piano_start').on('click', function() &#123; $(this).fadeOut(700); $('ul.piano').show(700).fadeIn(700); &#125;);$('#pone').on('click', function() &#123; if($('#sound1')[0].currentTime==0) $('#sound1')[0].play(); else &#123; $('#sound1')[0].load(); $('#sound1')[0].play(); &#125; var color=$(this).css('background-color'); $(this).animate( &#123; opacity: '0.2', backgroundColor: 'white' &#125;,300, function() &#123; $(this).animate( &#123; opacity: '1', backgroundColor: color &#125;,300 ) &#125; ) &#125;);$('#ptwo').on('click', function() &#123; if($('#sound2')[0].currentTime==0) $('#sound2')[0].play(); else &#123; $('#sound2')[0].load(); $('#sound2')[0].play(); &#125; var color=$(this).css('background-color'); $(this).animate( &#123; opacity: '0.2', backgroundColor: 'white' &#125;,300, function() &#123; $(this).animate( &#123; opacity: '1', backgroundColor: color &#125;,300 ) &#125; ) &#125;);$('#pthree').on('click', function() &#123; if($('#sound3')[0].currentTime==0) $('#sound3')[0].play(); else &#123; $('#sound3')[0].load(); $('#sound3')[0].play(); &#125; var color=$(this).css('background-color'); $(this).animate( &#123; opacity: '0.2', backgroundColor: 'white' &#125;,300, function() &#123; $(this).animate( &#123; opacity: '1', backgroundColor: color &#125;,300 ) &#125; ) &#125;);$('#pfour').on('click', function() &#123; if($('#sound4')[0].currentTime==0) $('#sound4')[0].play(); else &#123; $('#sound4')[0].load(); $('#sound4')[0].play(); &#125; var color=$(this).css('background-color'); $(this).animate( &#123; opacity: '0.2', backgroundColor: 'white' &#125;,300, function() &#123; $(this).animate( &#123; opacity: '1', backgroundColor: color &#125;,300 ) &#125; ) &#125;);$('#pfive').on('click', function() &#123; if($('#sound5')[0].currentTime==0) $('#sound5')[0].play(); else &#123; $('#sound5')[0].load(); $('#sound5')[0].play(); &#125; var color=$(this).css('background-color'); $(this).animate( &#123; opacity: '0.2', backgroundColor: 'white' &#125;,300, function() &#123; $(this).animate( &#123; opacity: '1', backgroundColor: color &#125;,300 ) &#125; ) &#125;);$('#psix').on('click', function() &#123; if($('#sound6')[0].currentTime==0) $('#sound6')[0].play(); else &#123; $('#sound6')[0].load(); $('#sound6')[0].play(); &#125; var color=$(this).css('background-color'); $(this).animate( &#123; opacity: '0.2', backgroundColor: 'white' &#125;,300, function() &#123; $(this).animate( &#123; opacity: '1', backgroundColor: color &#125;,300 ) &#125; ) &#125;);$('#pseven').on('click', function() &#123; if($('#sound7')[0].currentTime==0) $('#sound7')[0].play(); else &#123; $('#sound7')[0].load(); $('#sound7')[0].play(); &#125; var color=$(this).css('background-color'); $(this).animate( &#123; opacity: '0.2', backgroundColor: 'white' &#125;,300, function() &#123; $(this).animate( &#123; opacity: '1', backgroundColor: color &#125;,300 ) &#125; ) &#125;);$('body').on('keydown', function(e) &#123; if(e.which==49||e.which==97) &#123; if($('#sound1')[0].currentTime==0) $('#sound1')[0].play(); else &#123; $('#sound1')[0].load(); $('#sound1')[0].play(); &#125; var color=$('#pone').css('background-color'); $('#pone').animate( &#123; opacity: '0.2', backgroundColor: 'white' &#125;,300, function() &#123; $('#pone').animate( &#123; opacity: '1', backgroundColor: color &#125;,300 ) &#125; ) &#125;&#125;);$('body').on('keydown', function(e) &#123; if(e.which==50||e.which==98) &#123; if($('#sound2')[0].currentTime==0) $('#sound2')[0].play(); else &#123; $('#sound2')[0].load(); $('#sound2')[0].play(); &#125; var color=$('#ptwo').css('background-color'); $('#ptwo').animate( &#123; opacity: '0.2', backgroundColor: 'white' &#125;,300, function() &#123; $('#ptwo').animate( &#123; opacity: '1', backgroundColor: color &#125;,300 ) &#125; ) &#125;&#125;);$('body').on('keydown', function(e) &#123; if(e.which==51||e.which==99) &#123; if($('#sound3')[0].currentTime==0) $('#sound3')[0].play(); else &#123; $('#sound3')[0].load(); $('#sound3')[0].play(); &#125; var color=$('#pthree').css('background-color'); $('#pthree').animate( &#123; opacity: '0.2', backgroundColor: 'white' &#125;,300, function() &#123; $('#pthree').animate( &#123; opacity: '1', backgroundColor: color &#125;,300 ) &#125; ) &#125;&#125;);$('body').on('keydown', function(e) &#123; if(e.which==52||e.which==100) &#123; if($('#sound4')[0].currentTime==0) $('#sound4')[0].play(); else &#123; $('#sound4')[0].load(); $('#sound4')[0].play(); &#125; var color=$('#pfour').css('background-color'); $('#pfour').animate( &#123; opacity: '0.2', backgroundColor: 'white' &#125;,300, function() &#123; $('#pfour').animate( &#123; opacity: '1', backgroundColor: color &#125;,300 ) &#125; ) &#125;&#125;);$('body').on('keydown', function(e) &#123; if(e.which==53||e.which==101) &#123; if($('#sound5')[0].currentTime==0) $('#sound5')[0].play(); else &#123; $('#sound5')[0].load(); $('#sound5')[0].play(); &#125; var color=$('#pfive').css('background-color'); $('#pfive').animate( &#123; opacity: '0.2', backgroundColor: 'white' &#125;,300, function() &#123; $('#pfive').animate( &#123; opacity: '1', backgroundColor: color &#125;,300 ) &#125; ) &#125;&#125;);$('body').on('keydown', function(e) &#123; if(e.which==54||e.which==102) &#123; if($('#sound6')[0].currentTime==0) $('#sound6')[0].play(); else &#123; $('#sound6')[0].load(); $('#sound6')[0].play(); &#125; var color=$('#psix').css('background-color'); $('#psix').animate( &#123; opacity: '0.2', backgroundColor: 'white' &#125;,300, function() &#123; $('#psix').animate( &#123; opacity: '1', backgroundColor: color &#125;,300 ) &#125; ) &#125;&#125;);$('body').on('keydown', function(e) &#123; if(e.which==55||e.which==103) &#123; if($('#sound7')[0].currentTime==0) $('#sound7')[0].play(); else &#123; $('#sound7')[0].load(); $('#sound7')[0].play(); &#125; var color=$('#pseven').css('background-color'); $('#pseven').animate( &#123; opacity: '0.2', backgroundColor: 'white' &#125;,300, function() &#123; $('#pseven').animate( &#123; opacity: '1', backgroundColor: color &#125;,300 ) &#125; ) &#125;&#125;); 怎么使用？使用教程与这个使用方法是一样的]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery特效小实验]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF18%2F</url>
    <content type="text"><![CDATA[示例 jquery实验 click L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/assets/hibiki.model.json"},"display":{"position":"left","width":100,"height":300},"mobile":{"show":false},"log":false,"tagMode":false}); # 源代码 ## JavaScript部分 1234567891011121314$('#test1').css( &#123; 'background-color':'red', 'color':'white', 'width':'50%' &#125;);$('#test1').on('click',function() &#123; $('#test1').after($('&lt;h1&gt;确认点击&lt;/h1&gt;')); $('#test1').hide(800).sideDown(800); &#125;) html部分123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en" dir="ltr"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;jquery实验&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 id="test1"&gt;click&lt;/h1&gt; &lt;script src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="/js/src/jq.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo用jQuery实现背景图随机导入]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF17%2F</url>
    <content type="text"><![CDATA[不得不说jq确实好用一些，JavaScript我都不知道为啥控制不了body的background-image的css，真的很无语，换成jq就行了 源代码首先放上代码 JavaScript部分12345678910111213141516171819var pic=[ "https://i.loli.net/2019/02/23/5c702b57c3bbb.png", "https://i.loli.net/2019/02/23/5c702b5831271.jpg", "https://i.loli.net/2019/02/23/5c702b584bf33.png", "https://i.loli.net/2019/02/23/5c702b588ebcb.png", "https://i.loli.net/2019/02/23/5c702f87a58b5.jpg"];var i=Math.random();if(i&lt;=0.2)i=0;else if(i&lt;=0.4)i=1;else if(i&lt;=0.6)i=2;else if(i&lt;=0.8)i=3;elsei=4;$('body').css('background-image','url('+pic[i]+')'); CSS部分1234567body&#123; /*background-image: url(https://i.loli.net/2019/02/23/5c70b157320e8.jpg);*/ background-size: cover; background-repeat: no-repeat; background-attachment: fixed;&#125; 如何使用？首先在themes/source/js/src中创建一个bg.js(当然名字你随意)，然后把我JavaScript的代码复制进去，具体的那些图片你可以在pic数组中进行修改但是如果你数量变更的话，最好把随机数的那个选取也改一下然后在themes/layout/_ layout.swig的前添加 1&lt;script type="text/javascript" src="/js/src/bg.js"&gt;&lt;/script&gt; 这样我们算是完成了JavaScript部分的配置然后我们在themes/source/css/_ custom/custom.styl中开头加入CSS部分的语句即可最后hexo clean&amp;&amp;hexo g –d]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用JavaScript添加一个计时器选图的hexo博客文章底栏插件]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF16%2F</url>
    <content type="text"><![CDATA[源代码首先放上代码，html部分还用了一些css但是测试了一下发现只有img的盒子大小和文字居中有效，其他不知道为啥没效，还有就是hexo还是next好像并不支持用img的width和height属性所以我才加了css第一次写JavaScript脚本写的比较丑还多见谅其中在52行的pic数组中可以放入你喜欢的图片 JavaScript部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139var click1_html;var i=0;var loop1;var body;var re1,re2,re3,re4,re5,re6,re7;function click1()&#123; var dir=document.getElementById('one'); click1_html=dir; var p=dir.parentNode; body=p; p.removeChild(dir); var n=document.createElement('h1'); var n_text=document.createTextNode('点击选择按钮即可选择'); re1=n; n.appendChild(n_text); p.appendChild(n); var eimg=document.createElement('img'); re2=eimg; eimg.id='img1'; eimg.width='800'; eimg.height='600'; p.appendChild(eimg); var ebut=document.createElement('button'); ebut.type='button'; ebut.id='two'; var ebut_t=document.createTextNode('选择'); re3=ebut; var nn=document.createElement('br'); ebut.appendChild(ebut_t); p.appendChild(nn); p.appendChild(ebut); loop1=setInterval(changeImage,30); document.getElementById('two').addEventListener('click',click2,false);&#125;function changeImage()&#123; var pic=[ "https://i.loli.net/2019/02/22/5c6ff377c521d.jpg", "https://i.loli.net/2019/02/22/5c6ff377d0fc6.jpg", "https://i.loli.net/2019/02/22/5c6ff377d0d5f.png", "https://i.loli.net/2019/02/22/5c6ff377d1750.jpg", "https://i.loli.net/2019/02/22/5c6ff377d547f.jpg", "https://i.loli.net/2019/02/22/5c6ff377d563a.jpg", "https://i.loli.net/2019/02/22/5c6ff3780db68.jpg", "https://i.loli.net/2019/02/22/5c6ff3780f0f0.jpg", "https://i.loli.net/2019/02/22/5c6ff378167cb.jpeg", "https://i.loli.net/2019/02/22/5c6ff378178c8.jpeg", "https://i.loli.net/2019/02/22/5c6ff41dc472c.jpg", "https://i.loli.net/2019/02/22/5c6ff41dc6780.jpg", "https://i.loli.net/2019/02/22/5c6ff41dc87c9.jpg", "https://i.loli.net/2019/02/22/5c6ff41dc28c8.jpg", "https://i.loli.net/2019/02/22/5c6ff41dca549.jpg", "https://i.loli.net/2019/02/22/5c6ff41dcc4bb.jpg", "https://i.loli.net/2019/02/22/5c6ff41dd07c7.jpg", "https://i.loli.net/2019/02/22/5c6ff41dd2797.jpg", "https://i.loli.net/2019/02/22/5c6ff41dce646.jpg", "https://i.loli.net/2019/02/22/5c6ff41e61ebc.png" ]; i++; if(i&gt;=pic.length) i=0; document.getElementById('img1').src=pic[i];&#125;function click2()&#123; clearInterval(loop1); body.removeChild(re3); var n1=document.createElement('button'); var n2=document.createElement('button'); var h1=document.createElement('h1'); var n1_t=document.createTextNode('带回家！！！'); var n2_t=document.createTextNode('我选择放弃'); var h1_t=document.createTextNode('是否选择带回家？有一定的几率'); re4=h1; n1.appendChild(n1_t); n2.appendChild(n2_t); n1.id='yes'; n2.id='no'; h1.appendChild(h1_t); body.appendChild(h1); body.appendChild(n1); body.appendChild(n2); n1.addEventListener('click',yes1,false); n2.addEventListener('click',no1,false);&#125;var rand=Math.random();function yes1()&#123; if(rand&gt;=0.75) var now=alert('抱歉你并没有成功'); else var now=alert('恭喜你成功了！！！'); retry();&#125;function no1()&#123; var now=alert('真是一个让人遗憾的选择啊！！！'); retry();&#125;function retry()&#123; body.removeChild(document.getElementById('yes')); body.removeChild(document.getElementById('no')); var h1=document.createElement('h1'); var h1_t=document.createTextNode('是否要重新来过?'); re5=h1; var n1=document.createElement('button'); var n2=document.createElement('button'); var n1_t=document.createTextNode('是'); var n2_t=document.createTextNode('否'); n1.appendChild(n1_t); n2.appendChild(n2_t); re6=n1; re7=n2; h1.appendChild(h1_t); body.appendChild(h1); body.appendChild(n1); body.appendChild(n2); n1.addEventListener('click',yes2,false); n2.addEventListener('click',no2,false);&#125;function yes2()&#123; body.removeChild(re1); body.removeChild(re2); body.removeChild(re4); body.removeChild(re5); body.removeChild(re6); body.removeChild(re7); body.appendChild(click1_html);&#125;function no2()&#123; alert('你仍然可以刷新进行重新选择'); body.removeChild(re6); body.removeChild(re7);&#125;document.getElementById('one').addEventListener('click',click1,false); html部分1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang="en" dir="ltr"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;小游戏&lt;/title&gt; &lt;style&gt; #img1 &#123; width: 800px; height: 600px; border-style: outset; border-color: orange; &#125; body &#123; border-style: groove; border-width: medium; border: orange; &#125; #text1 &#123; text-align: center; &#125; #one &#123; margin: auto; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="border"&gt; &lt;h1 id="text1"&gt;---小游戏:要不要来选择一下自己可能的老婆？---&lt;/h1&gt; &lt;button type="button" id="one"&gt;开始&lt;/button&gt; &lt;script src="/js/src/game.js"&gt; &lt;/script&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 如何放到每篇文章的最底下？首先你需要在theme/layout目录下新建一个game.swig(当然名字随意)然后把html部分抄上去并且在开头加上 1&#123;% if theme.passage_end_tag.enabled %&#125; 接着在同目录下的post.swig中找到id为post-expand的div下加入 12345&lt;div &gt; &#123;% if not is_index %&#125; &#123;% include 'game.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 然后再找到theme/source/js/src新建一个game.js(同样名字可以随意)接着把所有的JavaScript代码复制进去即可最后hexo clean&amp;&amp;hexo g –d部署到服务器就行了]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorizedjs%2F</url>
    <content type="text"><![CDATA[Javascript实验 测试标题1 点击我 document.getElementById('test').innerHTML='TEST'; function check() { var x; var y=confirm('请点击'); if(y==true) x='thats good'; else x='thats bad'; document.getElementById('hide').textContent=x; } document.getElementById('onee').addEventListener('click',check,false); L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/assets/hibiki.model.json"},"display":{"position":"left","width":100,"height":300},"mobile":{"show":false},"log":false,"tagMode":false});]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 事件监听器的一个小小的实验]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF15%2F</url>
    <content type="text"><![CDATA[这里是实例 胡乱分析JavaScript的代码还是和html有些区别的。。。首先html的id要用双引号””而JavaScript的里面我看到的都是单引号’’并且不管是textConten还是innerHTML后面都是跟的字符串直接写的话要加’’还有就是如何看JavaScript的语法错误，实际上f12就可以查看了在浏览器中事件监听器用addEventListener(‘时间类型’,函数名,false); html 部分12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang="en" dir="ltr"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Javascript实验&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 id="test"&gt; 测试标题1 &lt;/h1&gt; &lt;button type="button" id="one"&gt;点击我&lt;/button&gt; &lt;h1 id="hide"&gt;&lt;/h1&gt; &lt;script&gt; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; JavaScript部分123456789101112document.getElementById('test').innerHTML='&lt;h1&gt;TEST&lt;/h1&gt;';function check()&#123; var x; var y=confirm('请点击'); if(y==true) x='thats good'; else x='thats bad'; document.getElementById('hide').textContent=x;&#125;document.getElementById('one').addEventListener('click',check,false);]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 540 (Div. 3)(补题)]]></title>
    <url>%2F%E8%A1%A5%E9%A2%9814%2F</url>
    <content type="text"><![CDATA[A. Water Buying(贪心)胡乱分析实际上没有什么难的，如果你用一种方案那么就要用到底，因为这只有两种情况方案一合适或者方案二合适，然后分n的奇偶性来输出即可 代码12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t; cin&gt;&gt;t; while(t--) &#123; long long n,a,b; cin&gt;&gt;n&gt;&gt;a&gt;&gt;b; if(n&amp;1) cout&lt;&lt;min(n*a,(n/2)*b+a)&lt;&lt;"\n"; else cout&lt;&lt;min((n/2)*b,n*a)&lt;&lt;"\n"; &#125;&#125; 今天早上我又用刚学的js来了一波，js弱数据类型语言第一次接触对他的判别有点不熟悉导致出现了一个小bug最终也调好了 代码123456789var n=parseInt(readline());for(var i=0;i&lt;n;i++)&#123; var s=readline().split(' '); if(s[0]%2==0) print(Math.min(s[0]*s[1],(s[0]/2)*s[2])); else print(Math.min(s[0]*s[1],Math.floor(s[0]/2)*s[2]+parseInt(s[1])));&#125; B. Tanya and Candies(思维)胡乱分析上来寻思了一阵最终得到了和出题人一样的思路奇数偶数项去掉的话奇数偶数会倒置所以根据这个特性来判断即可 代码1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;long long num[666666];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; long long sum1=0,sum2=0,sum11=0,sum22=0,ans=0,now1=0,now2=0; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;num[i]; if(i&amp;1) sum1+=num[i]; else sum2+=num[i]; &#125; sum11=sum1;sum22=sum2; for(int i=1;i&lt;=n;i++) &#123; if(i&amp;1) sum1-=num[i]; else sum2-=num[i]; if(now1+sum2==now2+sum1) ans++; if(i&amp;1) now1+=num[i]; else now2+=num[i]; &#125; cout&lt;&lt;ans;&#125; C. Palindromic Matrix(数学&amp;&amp;模拟)这个题目前还有争议主要就是出的有点复杂并且难度有点高，我现在也没有搞懂 D1. Coffee and Coursework (Easy version)(贪心)胡乱分析当时有点贪心的太容易了导致了wa，我最初想的是要都喝了然后如果不行留下当前天数的喝的数然后再继续循环喝完的操作但是实际上只留下一杯是远远的不够贪心的这里用一种非常简单的方法即可枚举出来留下合适的杯数 123for(int i=1;i&lt;=n;i++)for(int j=0;j&lt;n;j++)sum+=max(0,num[j]-j/i); 看着是非常的奇怪但是实际上这种方法能够保证计算出最优的答案，因为j如果不是i的倍数那么会一直累加到之前的天数上并且发生了自己应当的变化真的太美妙了！！！ 代码1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,m; cin&gt;&gt;n&gt;&gt;m; vector&lt;int&gt; num(n+10); for(int i=1;i&lt;=n;i++) cin&gt;&gt;num[i]; sort(num.rbegin(),num.rend()); for(int i=1;i&lt;=n;i++) &#123; int sum=0; for(int j=0;j&lt;n;j++) sum+=max(0,num[j]-j/i); if(sum&gt;=m) return cout&lt;&lt;i,0; &#125; cout&lt;&lt;-1;&#125; D2. Coffee and Coursework (Hard Version)(贪心&amp;&amp;二分)胡乱分析跟第D1不一样的地方就是限制了O(n2)的算法，那么对于这种能够靠条件判断出范围的问题我们可以用二分搜索来减少时间复杂度这里也是又对二分有了一些理解并且也准备以后按照MikeMirzayanov的写法进行书写 12345678910while(r-l&gt;precision) //这里的precision是一个精度可以如果是整数那么就是1，小数的话保留小数位数向上一位即可&#123; int mid=(l+r)&gt;&gt;1; //如果是小数的话改成double if(check(mid)) //转换边界 else //转换边界 //这里的转换边界看是要求一个范围内的最小值还是最大值，最小值的话就是缩小右边界否则就是缩小左边界&#125; 代码123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; num(666666);int n,m;int check(int x)&#123; long long sum=0; for(int i=0;i&lt;n;i++) sum+=max(0,num[i]-i/x); return sum&gt;=m;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) cin&gt;&gt;num[i]; sort(num.rbegin(),num.rend()); int l=1,r=n; while(r-l&gt;1) &#123; int mid=(r+l)&gt;&gt;1; if(check(mid)) r=mid; else l=mid; &#125; if(check(l)) cout&lt;&lt;l; else if(check(r)) cout&lt;&lt;r; else cout&lt;&lt;-1;&#125;]]></content>
      <categories>
        <category>补题</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3动画实验]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF13%2F</url>
    <content type="text"><![CDATA[下面是例子点击这里查看 如何实现基础的动画?主要是要注意@keyframes基础的是from to其他的用%来规定的，一般是必须要写上0%和100%的如果要进行移动的操作那么position就得是relative然后进行一些relative的操作 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385&lt;!DOCTYPE html&gt;&lt;html lang="en" dir="ltr"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;CSS3动画实验&lt;/title&gt; &lt;style&gt; div.one &#123; background-color: blue; width: 400px; height: 400px; animation: a1 5s infinite; &#125; @keyframes a1 &#123; 0% &#123;background:red;&#125; 25% &#123;background:yellow;&#125; 50% &#123;background:blue;&#125; 100% &#123;background:green;&#125; &#125; div.two &#123; height: 200px; width: 200px; background-color: red; animation: a2 5s infinite; position: relative; &#125; @keyframes a2 &#123; 0% &#123;background:red; left:0px; top:0px;&#125; 25% &#123;background:yellow; left:200px; top:0px;&#125; 50% &#123;background:blue; left:200px; top:200px;&#125; 75% &#123;background:green; left:0px; top:200px;&#125; 100% &#123;background:red; left:0px; top:0px;&#125; &#125; .solarsys&#123; width: 800px; height: 800px;; position: relative; margin: 0 auto; background-color: #000000; padding: 0; transform: scale(1);&#125;/*太阳*/.sun &#123; left:357px; top:357px; height: 90px; width: 90px; background-color: rgb(248,107,35); border-radius: 50%; box-shadow: 5px 5px 10px rgb(248,107,35), -5px -5px 10px rgb(248,107,35), 5px -5px 10px rgb(248,107,35), -5px 5px 10px rgb(248,107,35); position: absolute; margin: 0;&#125;/*水星*/.mercury &#123; left:337.5px; top:395px; height: 10px; width: 10px; background-color: rgb(166,138,56); border-radius: 50%; position: absolute; transform-origin: 62.5px 5px; animation: rotate 1.5s infinite linear;&#125;/*水星轨道*/.mercuryOrbit &#123; left:342.5px; top:342.5px; height: 115px; width: 115px; background-color: transparent; border-radius: 50%; border-style: dashed; border-color: gray; position: absolute; border-width: 1px; margin: 0px; padding: 0px;&#125;/*金星*/.venus &#123; left:309px; top:389px; height: 22px; width: 22px; background-color: rgb(246,157,97); border-radius: 50%; position: absolute; transform-origin: 91px 11px; animation: rotate 3.84s infinite linear;&#125;/*金星轨道*/.venusOrbit &#123; left:320px; top:320px; height: 160px; width: 160px; background-color: transparent; border-radius: 50%; border-style: dashed; border-color: gray; position: absolute; border-width: 1px; /*margin: 100px;*/ /*transform-origin: -75px -75px;*/ /*animation: rotate 4s infinite linear;*/ margin: 0px; padding: 0px;&#125;/*地球*/.earth &#123; left:266.5px; top:391px; height: 18px; width: 18px; background-color: rgb(115,114,174); border-radius: 50%; position: absolute; transform-origin: 134px 9px; animation: rotate 6.25s infinite linear;&#125;/*地球轨道*/.earthOrbit &#123; left:275px; top:275px; height: 250px; width: 250px; background-color: transparent; border-radius: 50%; border-style: dashed; border-color: gray; position: absolute; border-width: 1px; /*margin: 100px;*/ /*transform-origin: -75px -75px;*/ /*animation: rotate 4s infinite linear;*/ margin: 0px; padding: 0px;&#125;/*火星*/.mars &#123; left:222.5px; top:392.5px; height: 15px; width: 15px; background-color: rgb(140,119,63); border-radius: 50%; position: absolute; transform-origin: 177.5px 7.5px; animation: rotate 11.75s infinite linear;&#125;/*火星轨道*/.marsOrbit &#123; left:230px; top:230px; height: 340px; width: 340px; background-color: transparent; border-radius: 50%; border-style: dashed; border-color: gray; position: absolute; border-width: 1px; /*margin: 100px;*/ /*transform-origin: -75px -75px;*/ /*animation: rotate 4s infinite linear;*/ margin: 0px; padding: 0px;&#125;/*木星*/.jupiter &#123; left:134px; top:379px; height: 42px; width: 42px; background-color: rgb(156,164,143); border-radius: 50%; position: absolute; transform-origin: 266px 21px; animation: rotate 74.04s infinite linear;&#125;/*木星轨道*/.jupiterOrbit &#123; left:155px; top:155px; height: 490px; width: 490px; background-color: transparent; border-radius: 50%; border-style: dashed; border-color: gray; position: absolute; border-width: 1px; /*margin: 100px;*/ /*transform-origin: -75px -75px;*/ /*animation: rotate 4s infinite linear;*/ margin: 0px; padding: 0px;&#125;/*土星*/.saturn &#123; left:92px; top:387px; height: 26px; width: 26px; background-color: rgb(215,171,68); border-radius: 50%; position: absolute; transform-origin: 308px 13px; animation: rotate 183.92s infinite linear;&#125;/*土星轨道*/.saturnOrbit &#123; left:105px; top:105px; height: 590px; width: 590px; background-color: transparent; border-radius: 50%; border-style: dashed; border-color: gray; position: absolute; border-width: 1px; /*margin: 100px;*/ /*transform-origin: -75px -75px;*/ /*animation: rotate 4s infinite linear;*/ margin: 0px; padding: 0px;&#125;/*天王星*/.uranus &#123; left:41.5px; top:386.5px; height: 27px; width: 27px; background-color: rgb(164,192,206); border-radius: 50%; position: absolute; transform-origin: 358.5px 13.5px; animation: rotate 524.46s infinite linear;&#125;/*天王星轨道*/.uranusOrbit &#123; left:55px; top:55px; height: 690px; width: 690px; background-color: transparent; border-radius: 50%; border-style: dashed; border-color: gray; position: absolute; border-width: 1px; /*margin: 100px;*/ /*transform-origin: -75px -75px;*/ /*animation: rotate 4s infinite linear;*/ margin: 0px; padding: 0px;&#125;/*海王星*/.neptune &#123; left:10px; top:390px; height: 20px; width: 20px; background-color: rgb(133,136,180); border-radius: 50%; position: absolute; transform-origin: 390px 10px; animation: rotate 1028.76s infinite linear;&#125;/*海王星轨道*/.neptuneOrbit &#123; left:20px; top:20px; height: 760px; width: 760px; background-color: transparent; border-radius: 50%; border-style: dashed; border-color: gray; position: absolute; border-width: 1px; /*margin: 100px;*/ /*transform-origin: -75px -75px;*/ /*animation: rotate 4s infinite linear;*/ margin: 0px; padding: 0px;&#125;@keyframes rotate &#123; 100% &#123; transform: rotate(-360deg); &#125;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;下面请尽情欣赏动画&lt;/h1&gt; &lt;p&gt;这是一个基础的颜色变换&lt;/p&gt; &lt;div class="one"&gt; &lt;/div&gt; &lt;p&gt;这是一个带移动的动画&lt;/p&gt; &lt;div class="two"&gt; &lt;/div&gt; &lt;br /&gt; &lt;br /&gt; &lt;br /&gt; &lt;p&gt;大佬的太阳系公转动画orz&lt;/p&gt; &lt;div class="solarsys"&gt; &lt;!--太阳--&gt; &lt;div class='sun'&gt;&lt;/div&gt; &lt;!--水星轨道--&gt; &lt;div class='mercuryOrbit'&gt;&lt;/div&gt; &lt;!--水星--&gt; &lt;div class='mercury'&gt;&lt;/div&gt; &lt;!--金星轨道--&gt; &lt;div class='venusOrbit'&gt;&lt;/div&gt; &lt;!--金星--&gt; &lt;div class='venus'&gt;&lt;/div&gt; &lt;!--地球轨道--&gt; &lt;div class='earthOrbit'&gt;&lt;/div&gt; &lt;!--地球--&gt; &lt;div class='earth'&gt;&lt;/div&gt; &lt;!--火星轨道--&gt; &lt;div class='marsOrbit'&gt;&lt;/div&gt; &lt;!--火星--&gt; &lt;div class='mars'&gt;&lt;/div&gt; &lt;!--木星轨道--&gt; &lt;div class='jupiterOrbit'&gt;&lt;/div&gt; &lt;!--木星--&gt; &lt;div class='jupiter'&gt;&lt;/div&gt; &lt;!--土星轨道--&gt; &lt;div class='saturnOrbit'&gt;&lt;/div&gt; &lt;!--土星--&gt; &lt;div class='saturn'&gt;&lt;/div&gt; &lt;!--天王星轨道--&gt; &lt;div class='uranusOrbit'&gt;&lt;/div&gt; &lt;!--天王星--&gt; &lt;div class='uranus'&gt;&lt;/div&gt; &lt;!--海王星轨道--&gt; &lt;div class='neptuneOrbit'&gt;&lt;/div&gt; &lt;!--海王星--&gt; &lt;div class='neptune'&gt;&lt;/div&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorizedcss3%20animation%2F</url>
    <content type="text"><![CDATA[CSS3动画实验 div.one { background-color: blue; width: 400px; height: 400px; animation: a1 5s infinite; } @keyframes a1 { 0% {background:red;} 25% {background:yellow;} 50% {background:blue;} 100% {background:green;} } div.two { height: 200px; width: 200px; background-color: red; animation: a2 5s infinite; position: relative; } @keyframes a2 { 0% {background:red; left:0px; top:0px;} 25% {background:yellow; left:200px; top:0px;} 50% {background:blue; left:200px; top:200px;} 75% {background:green; left:0px; top:200px;} 100% {background:red; left:0px; top:0px;} } .solarsys{ width: 800px; height: 800px;; position: relative; margin: 0 auto; background-color: #000000; padding: 0; transform: scale(1); } /*太阳*/ .sun { left:357px; top:357px; height: 90px; width: 90px; background-color: rgb(248,107,35); border-radius: 50%; box-shadow: 5px 5px 10px rgb(248,107,35), -5px -5px 10px rgb(248,107,35), 5px -5px 10px rgb(248,107,35), -5px 5px 10px rgb(248,107,35); position: absolute; margin: 0; } /*水星*/ .mercury { left:337.5px; top:395px; height: 10px; width: 10px; background-color: rgb(166,138,56); border-radius: 50%; position: absolute; transform-origin: 62.5px 5px; animation: rotate 1.5s infinite linear; } /*水星轨道*/ .mercuryOrbit { left:342.5px; top:342.5px; height: 115px; width: 115px; background-color: transparent; border-radius: 50%; border-style: dashed; border-color: gray; position: absolute; border-width: 1px; margin: 0px; padding: 0px; } /*金星*/ .venus { left:309px; top:389px; height: 22px; width: 22px; background-color: rgb(246,157,97); border-radius: 50%; position: absolute; transform-origin: 91px 11px; animation: rotate 3.84s infinite linear; } /*金星轨道*/ .venusOrbit { left:320px; top:320px; height: 160px; width: 160px; background-color: transparent; border-radius: 50%; border-style: dashed; border-color: gray; position: absolute; border-width: 1px; /*margin: 100px;*/ /*transform-origin: -75px -75px;*/ /*animation: rotate 4s infinite linear;*/ margin: 0px; padding: 0px; } /*地球*/ .earth { left:266.5px; top:391px; height: 18px; width: 18px; background-color: rgb(115,114,174); border-radius: 50%; position: absolute; transform-origin: 134px 9px; animation: rotate 6.25s infinite linear; } /*地球轨道*/ .earthOrbit { left:275px; top:275px; height: 250px; width: 250px; background-color: transparent; border-radius: 50%; border-style: dashed; border-color: gray; position: absolute; border-width: 1px; /*margin: 100px;*/ /*transform-origin: -75px -75px;*/ /*animation: rotate 4s infinite linear;*/ margin: 0px; padding: 0px; } /*火星*/ .mars { left:222.5px; top:392.5px; height: 15px; width: 15px; background-color: rgb(140,119,63); border-radius: 50%; position: absolute; transform-origin: 177.5px 7.5px; animation: rotate 11.75s infinite linear; } /*火星轨道*/ .marsOrbit { left:230px; top:230px; height: 340px; width: 340px; background-color: transparent; border-radius: 50%; border-style: dashed; border-color: gray; position: absolute; border-width: 1px; /*margin: 100px;*/ /*transform-origin: -75px -75px;*/ /*animation: rotate 4s infinite linear;*/ margin: 0px; padding: 0px; } /*木星*/ .jupiter { left:134px; top:379px; height: 42px; width: 42px; background-color: rgb(156,164,143); border-radius: 50%; position: absolute; transform-origin: 266px 21px; animation: rotate 74.04s infinite linear; } /*木星轨道*/ .jupiterOrbit { left:155px; top:155px; height: 490px; width: 490px; background-color: transparent; border-radius: 50%; border-style: dashed; border-color: gray; position: absolute; border-width: 1px; /*margin: 100px;*/ /*transform-origin: -75px -75px;*/ /*animation: rotate 4s infinite linear;*/ margin: 0px; padding: 0px; } /*土星*/ .saturn { left:92px; top:387px; height: 26px; width: 26px; background-color: rgb(215,171,68); border-radius: 50%; position: absolute; transform-origin: 308px 13px; animation: rotate 183.92s infinite linear; } /*土星轨道*/ .saturnOrbit { left:105px; top:105px; height: 590px; width: 590px; background-color: transparent; border-radius: 50%; border-style: dashed; border-color: gray; position: absolute; border-width: 1px; /*margin: 100px;*/ /*transform-origin: -75px -75px;*/ /*animation: rotate 4s infinite linear;*/ margin: 0px; padding: 0px; } /*天王星*/ .uranus { left:41.5px; top:386.5px; height: 27px; width: 27px; background-color: rgb(164,192,206); border-radius: 50%; position: absolute; transform-origin: 358.5px 13.5px; animation: rotate 524.46s infinite linear; } /*天王星轨道*/ .uranusOrbit { left:55px; top:55px; height: 690px; width: 690px; background-color: transparent; border-radius: 50%; border-style: dashed; border-color: gray; position: absolute; border-width: 1px; /*margin: 100px;*/ /*transform-origin: -75px -75px;*/ /*animation: rotate 4s infinite linear;*/ margin: 0px; padding: 0px; } /*海王星*/ .neptune { left:10px; top:390px; height: 20px; width: 20px; background-color: rgb(133,136,180); border-radius: 50%; position: absolute; transform-origin: 390px 10px; animation: rotate 1028.76s infinite linear; } /*海王星轨道*/ .neptuneOrbit { left:20px; top:20px; height: 760px; width: 760px; background-color: transparent; border-radius: 50%; border-style: dashed; border-color: gray; position: absolute; border-width: 1px; /*margin: 100px;*/ /*transform-origin: -75px -75px;*/ /*animation: rotate 4s infinite linear;*/ margin: 0px; padding: 0px; } @keyframes rotate { 100% { transform: rotate(-360deg); } } 下面请尽情欣赏动画 这是一个基础的颜色变换 这是一个带移动的动画 大佬的太阳系公转动画orz L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/assets/hibiki.model.json"},"display":{"position":"left","width":100,"height":300},"mobile":{"show":false},"log":false,"tagMode":false});]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorizedcss3%2F</url>
    <content type="text"><![CDATA[css3过渡测试 div.one { width: 400px; height: 400px; background-color: red; transition: width 2s; } div.one:hover { width: 200px; } div.two { width: 400px; height: 400px; background-color: blue; transition: all 2s; } div.two:hover { background-color: yellow; transform: rotate(270deg) translate(100px,100px); } div.three { width: 400px; height: 400px; background-color: black; transition: all 3s; } div.three:hover { width: 200px; height: 200px; background-color: white; transform: rotateY(360deg); } 下面演示几种过渡效果，你只需要把鼠标放上即可 这是第一种效果 这是第二种效果 这是第三种效果 L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/assets/hibiki.model.json"},"display":{"position":"left","width":100,"height":300},"mobile":{"show":false},"log":false,"tagMode":false});]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSS3过渡实验]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF12%2F</url>
    <content type="text"><![CDATA[既然是要过渡那么就需要先看看过渡是什么了下面放例子点击这里查看效果 过渡的实现css3 2D与3D变换全部用到transform属性2d和3d都是通用的格式2d:translate() rotate() scale()字面意思就是变换位置旋转变换大小3d:translateX translateY translatezZ其他的一样都是加上XYZ即可 过渡用到了transition: all xs;x更改为你需要转换的时间之后只需要再定义一个hover伪类进行鼠标放上去的一顿2d3d变换即可 源代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang="en" dir="ltr"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;css3过渡测试&lt;/title&gt; &lt;style&gt; div.one &#123; width: 400px; height: 400px; background-color: red; transition: width 2s; &#125; div.one:hover &#123; width: 200px; &#125; div.two &#123; width: 400px; height: 400px; background-color: blue; transition: all 2s; &#125; div.two:hover &#123; background-color: yellow; transform: rotate(270deg) translate(100px,100px); &#125; div.three &#123; width: 400px; height: 400px; background-color: black; transition: all 3s; &#125; div.three:hover &#123; width: 200px; height: 200px; background-color: white; transform: rotateY(360deg); &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;&lt;b&gt;下面演示几种过渡效果,你只需要把鼠标放上即可&lt;/b&gt;&lt;/h1&gt; &lt;div class="one"&gt; &lt;/div&gt; &lt;p&gt;这是第一种效果&lt;/p&gt; &lt;div class="two"&gt; &lt;/div&gt; &lt;p&gt;这是第二种效果&lt;/p&gt; &lt;div class="three"&gt; &lt;/div&gt; &lt;p&gt;这是第三种效果&lt;/p&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bfs判断转弯次数]]></title>
    <url>%2F%E7%AE%97%E6%B3%9511%2F</url>
    <content type="text"><![CDATA[bfs判断转弯次数也就是顾名思义我们如何来应对需要至少转弯多少次或者计算总共转弯多少次的题目 胡乱分析例题 P1649 [USACO07OCT]障碍路线Obstacle Course算法核心在于对每个能到达的部分进行枚举然后进行一波更新 123456789101112131415for(int i=0;i&lt;4;i++)&#123; int xx=p.x+dx[i]; int yy=p.y+dy[i]; while(check(xx,yy)) &#123; if(step[xx][yy]&gt;step[p.x][p.y]+1) &#123; step[xx][yy]=step[p.x][p.y]+1; q.push((node)&#123;xx,yy&#125;); &#125; xx+=dx[i]; yy+=dy[i]; &#125;&#125; 还需要注意除了开始节点设置为-1其他节点初始化都为inf(也就是一个极大值) 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;char mp[666][666];int sx,sy,ex,ey,f,step[666][666];struct node&#123; int x,y;&#125;;int dx[]=&#123;-1,1,0,0&#125;;int dy[]=&#123;0,0,-1,1&#125;;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) &#123; cin&gt;&gt;mp[i][j]; if(mp[i][j]=='A') sx=i,sy=j; else if(mp[i][j]=='B') ex=i,ey=j; step[i][j]=99999; &#125; step[sx][sy]=-1; queue&lt;node&gt; q; q.push((node)&#123;sx,sy&#125;); while(q.size()) &#123; node p=q.front(); q.pop(); if(p.x==ex&amp;&amp;p.y==ey) &#123; f=1; break; &#125; for(int i=0;i&lt;4;i++) &#123; int xx=p.x+dx[i]; int yy=p.y+dy[i]; while(xx&gt;=1&amp;&amp;yy&gt;=1&amp;&amp;xx&lt;=n&amp;&amp;yy&lt;=n&amp;&amp;mp[xx][yy]!='x') &#123; if(step[xx][yy]&gt;step[p.x][p.y]+1) &#123; step[xx][yy]=step[p.x][p.y]+1; q.push((node)&#123;xx,yy&#125;); &#125; xx+=dx[i]; yy+=dy[i]; &#125; &#125; &#125; cout&lt;&lt;(f?step[ex][ey]:-1);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html学习(1)]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF10%2F</url>
    <content type="text"><![CDATA[本文我准备都用html进行书写 实际上也没有多少需要书写的内容直接放上这部分的代码即可了 这次也是基本的学习完了html的一些基础操作 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110&lt;html&gt; &lt;head&gt; &lt;title&gt;my first html&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;this is h1&lt;/h1&gt; &lt;p&gt;this is p&lt;/p&gt; &lt;p&gt;&lt;b&gt;粗体字&lt;/b&gt;&lt;/p&gt; &lt;p&gt;&lt;i&gt;italic&lt;/i&gt;&lt;/p&gt; &lt;p&gt;e=mc&lt;sup&gt;2&lt;/sup&gt;&lt;/p&gt; &lt;p&gt;co&lt;sub&gt;2&lt;/sub&gt;&lt;/p&gt; &lt;p&gt;换行符&lt;br /&gt;换行符&lt;/p&gt; &lt;p&gt;插入横线&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;横线下面&lt;/p&gt; &lt;p&gt;&lt;strong&gt;strong&lt;/strong&gt; &lt;em&gt;em&lt;/em&gt; &lt;/p&gt; &lt;blockquote cite="http://www.baidu.com"&gt; &lt;p&gt;前往百度&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;&lt;cite&gt;cite&lt;/cite&gt;&lt;/p&gt; &lt;p&gt;&lt;dfn&gt;dfn&lt;/dfn&gt;&lt;/p&gt; &lt;p&gt;&lt;ins&gt;ins&lt;/ins&gt;&lt;del&gt;del&lt;/del&gt;&lt;/p&gt; &lt;p&gt;&lt;s&gt;s&lt;/s&gt;&lt;/p&gt; &lt;ol&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ol&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;dl&gt; &lt;dt&gt;1&lt;/dt&gt; &lt;dd&gt;1的内容&lt;/dd&gt; &lt;dt&gt;2&lt;/dt&gt; &lt;dd&gt;2的内容&lt;/dd&gt; &lt;/dl&gt; &lt;a href="https://www.baidu.com"&gt;baidu&lt;/a&gt; &lt;br /&gt; &lt;a href="https://www.baidu.com" target="_blank"&gt;baidu&lt;/a&gt; &lt;br /&gt; &lt;figure&gt; &lt;img src="https://i.loli.net/2019/02/14/5c64fb8ce8b64.jpeg" alt="一张图片" /&gt; &lt;br /&gt; &lt;figcaption&gt; 图片的描述 &lt;/figcaption&gt; &lt;/figure&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;15&lt;/td&gt; &lt;td&gt;15&lt;/td&gt; &lt;td&gt;30&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;15&lt;/td&gt; &lt;td&gt;15&lt;/td&gt; &lt;td&gt;30&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;15&lt;/td&gt; &lt;td&gt;15&lt;/td&gt; &lt;td&gt;30&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt; &lt;th scope="col"&gt;c1&lt;/th&gt; &lt;th scope="col"&gt;c2&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th scope="row"&gt;r1&lt;/th&gt; &lt;td&gt;120&lt;/td&gt; &lt;td&gt;130&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th scope="row"&gt;r2&lt;/th&gt; &lt;td&gt;$600&lt;/td&gt; &lt;td&gt;$675&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;form class="" action="index.html" method="post"&gt; &lt;p&gt; username: &lt;input type="text" name="username" size="15"&gt; &lt;/p&gt; &lt;/form&gt; &lt;form class="" action="index.html" method="post"&gt; &lt;p&gt;密码 &lt;input type="password" name="密码" value="" size="15"&gt; &lt;/p&gt; &lt;/form&gt; &lt;form class="" action="index.html" method="post"&gt; &lt;p&gt;选择一下 &lt;br /&gt; &lt;input type="radio" name="genre" value="rock" checked="checked" /&gt; rock &lt;input type="radio" name="genre" value="pop" /&gt; pop &lt;input type="radio" name="genre" value="jazz" /&gt; jazz &lt;/p&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[背包变形:过程型背包]]></title>
    <url>%2F%E7%AE%97%E6%B3%959%2F</url>
    <content type="text"><![CDATA[过程型背包简单的感觉就是我要记录下是否回到这种情况，也就是说要记录一个最大到达的可能值或者是一个最小到达的可能值 #例1 P1877 [HAOI2012]音量调节 胡乱分析上来bfs得60分。。。dp的思路就是我看看我能最终到达的最大音量是多少，每一步都有两种可能性，也就是我要加音量或者我要减当前的音量所以我们思路就是:for i-&gt;[1,n] (这里表示我们总共弹奏的歌曲数) for j-&gt;[0,maxn] (这里表示我们j从0枚举到最大值) if dp[i-1][j] dp[i][j+num[i]]=dp[i][j-num[i]]=1 (这里表示我们如果上一个音量是合法的那么我们把他所能表示出来的音量也标记为合法的) 代码123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;int num[6666],dp[6666][6666];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,begin,maxn; cin&gt;&gt;n&gt;&gt;begin&gt;&gt;maxn; for(int i=1;i&lt;=n;i++) cin&gt;&gt;num[i]; dp[0][begin]=1; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;=maxn;j++) &#123; if(dp[i-1][j]) dp[i][j+num[i]]=dp[i][j-num[i]]=1; &#125; for(int i=maxn;i&gt;=0;i--) if(dp[n][i]) return cout&lt;&lt;i,0; cout&lt;&lt;-1;&#125; 例2 待补充]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[完全背包变形(1) 取数问题]]></title>
    <url>%2F%E7%AE%97%E6%B3%958%2F</url>
    <content type="text"><![CDATA[朴素的完全背包就是总容量一定物品无限能放多少东西，这里记录一下最近遇到的变形取数问题 首先需要说明一下板子的基本情况:一个数分解为几个数的和的形式有多少种方案数或者最多/最少能分解为多少位? 例1 P1832 A+B Problem（再升级）胡乱分析看着像是要搜索但是我感觉搜索应该得tle，这个就是比较朴素的取数问题变形了首先我们定义v是背包容量,n是[2,n]内有多少个质数这样把质数放进背包的板子就成型了注意初始值设定dp[0]=1表示什么都不装是有1个的(即这个数本身也算一种) 代码1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;int isp(int n)&#123; for(int i=2;i*i&lt;=n;i++) if(n%i==0) return 0; return 1;&#125;long long dp[6666],bk[6666],mk[6666],v[6666],p=1;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,sum=0; dp[0]=1; for(int i=2;i&lt;=1000;i++) if(isp(i)) bk[i]=1; for(int i=2;i&lt;=1000;i++) &#123; if(bk[i]) &#123; v[p++]=i; sum++; &#125; mk[i]=sum; &#125; cin&gt;&gt;n; for(int i=1;i&lt;=mk[n];i++) for(int j=v[i];j&lt;=n;j++) dp[j]+=dp[j-v[i]]; cout&lt;&lt;dp[n];&#125; 例2 P1679 神奇的四次方数胡乱分析跟例一一模一样注意这里就是把素数换成了四方数把方案数换成了最少的个数同样套板子即可v是这个数的大小，n是[1,n]内有几个四方数这里dp[0]=0数本身不算分解的一部分 代码123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;double num[66666],mk[666666];int sum,p=1,dp[666666];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); memset(dp,0x7f,sizeof(dp)); dp[0]=0; for(double i=1;;i++) if(pow(i,4)&lt;=1e5) num[p++]=pow(i,4); else break; p=1; for(int i=1;i&lt;=int(1e5);i++) &#123; if(i==num[p]) &#123; p++; sum++; &#125; mk[i]=sum; &#125; int n; cin&gt;&gt;n; for(int i=1;i&lt;=mk[n];i++) for(int j=num[i];j&lt;=n;j++) dp[j]=min(dp[j],dp[int(j-num[i])]+1); cout&lt;&lt;dp[n];&#125; 例3 自然数无序拆分题目描述(摘自中石油oj 10255)美羊羊给喜羊羊和沸羊羊出了一道难题，说谁能先做出来，我就奖励给他我自己做的一样礼物。沸羊羊这下可乐了，于是马上答应立刻做出来，喜羊羊见状，当然也不甘示弱，向沸羊羊发起了挑战。可是这道题目有一些难度，喜羊羊做了一会儿，见沸羊羊也十分头疼，于是就来请教你。题目是这样的：把自然数Ｎ（N&lt;＝100）分解为若干个自然数之和，求出有几种情况。如N＝5时，有7种情况5=1+1+1+1+15=1+1+1+25=1+1+35=1+2+25=1+45=2+35=5怎么样？你要加油帮助喜羊羊哦！ 胡乱分析还是典型的问题，这个更简单了。。。实际上就是套板子即可v是n个数n是n个数注意dp[0]=1代表数本身是算一个的 代码12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int dp[666];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; cin&gt;&gt;n; dp[0]=1; for(int i=1;i&lt;=n;i++) for(int j=i;j&lt;=n;j++) dp[j]+=dp[j-i]; cout&lt;&lt;dp[n];&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[站内更新日志]]></title>
    <url>%2F%E8%AE%B0%E5%BD%950%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX19fAhdrLvGSwWgSKlYuS2GrHI0lt6C6k7tJ64NZl428pnmWBx8cElD4sid6LZTqA/wJt/mHNTdXi1rgemFTqk1hNM/9GMKFLTGCQTIkaNMdeh1hx51mhot1BbZPp4EUSPxlKaQBQOcU3hhA2P6WvRY8Vk7Vzd0row4YE2CsEG3MXUjCRU1ngx+mXhBMcyssZvUJ6pgMtnn3FaMR90c5KLte8tge25aTMktNyJq7wSIDo1pM7hv34rVEHke3RCM1tLGaVLPRB1/UDNYFAxmzKR/Tzv5l7YaIk3cmmHrThw+dLHbY66P8t0C2yyPtibUHz8B2LaYPfgtJSNxAih5+KZRo9doxB4cY3VDYrCS4dLZA59PAhX12M9WpTpfP19varZ78cTGdP/z4kr8LhWxXLwNYH83yzrEZdBwYwALRayZuhcVvPCFX37DQoHAQ+IEpsK4q+oqky8n6PA0TJMxguk2z3gbCit6JZ7U9zn8SLjSMIjZ4I//GfKwGDtBX/qUIDS9Si/KWfjW2uSgDq5RnAeRX/BCbvDB/Bm4u7YgocAcSSWU5aV8dKfkIPBwfLcXalDOnHJW5SApCSxhOAvZXZXNTqHC+N4b+/Wwh1lLI/0TikTE7aeZuQ3s34xmTprGtpFTQc9EMuTUN7ePUaagBSIxDo20Da+AH611Y1DPZy7+yPaNm34VduXSxPIE1HcqYyKV/LFm7AEQKFngR71HNq31lKE2mLxnGf58oO8EmDMpXuxPHwDSNmjKGXee7E0uAMMOyCTJX/5FevUNYzF7Ep2gYzLkNMrzfrlSfIGxlpt4gh1If9bbnhRG0bvIDfUONiEPAmTQDefR0MjnGpxFN1HCQ6vnVCJOBTer/Y2ttMHCE3GllxmPB8OVjNRnkknC9jWqjNngDDogiIwJ5t7D80HvBd36S7SATgwjZb+J3cTRMYPfbxV9jOqN+rsHc7dRzzvF0dC17kYwF5ue3QkVBRoIo8qZRWw6RTslbF09JVJBcjTDutOQOQn7s6zYRbyKCT5sHjDuhgkqGnPs/6k7VCUC/lqOLlYhfqhW5qN+vNTjOOEwKTx7Hx0jTVm+5gnr70XaXlnIu0M0cCMj/K83NkINGs2lo3W4/xk29/VszyyI/GbvE9LTO3E9vqzeE1m5FFT2oIFaXfh+/seLhX1qaKgmE12+zCLGGr0/iTNLx6dvYJTGAA+5DGQ5cD+pOYe4kHlVctDlSYAyRx0vFR96o4Qp2OWmIadc2sz76sk6MkJ5wytkc6cEv+F+OCswR5+xbKYAZS+2tqju1TQDJQkVNo74r69lAIA1XZ97PwyHJDrZNHcfM0IO9szR/5ivApI3LvnQJ4pII+V4oo5pkzI1ZJwC9NDJ/AXANBGb7azoD3BwiV0LHHd1HyF/0IV5yb6nhAYyjqjM59LlYZY/kfrTGakw6VtIVLz+X+jeA2NHfIkvJCcq+p8t/7VLHIro/T5mXJzcOFWqsvtiVurc8a8ntrG2ZnimW/0/mIfhCVZXa+xZv+svYnzmysb5rza3HLIqJI9WvtHDXEeWnBpqInfMaz0n5C/BCAlqhAL/GqZJcaBixo8TwFQB9A8SAlDGjh6xx7BfP1bYLs3K7Fq87mxzUczCweo5WaWLyWnIx7MOiIG9M7lSnKqAaRUL3xAiVYMnMucmEbuQXoNDZ5GccrmJ5+vB/iGCklfLXecunPj8ZsgH33ruJBZnGjlF0hh0rvzDKHi8vKyveT1bynSsxzALVSkYkdAbinJ0R/isBQL591DjU11EV+mibp8kVZSzrXKyQW1Y4/VKxRgzod+0tXGTRd2kf7PHfWyuUy7ytVA1+yFKVKjVymbymVJo18Ki+xBOczK4P1i/zZeVHXanPEPEAGmpMx4z459Q6UnTjU0h9X++zbKjP8m9t1XMRbEPFgr1W/A7HL9ApgEijXl4U96NpgBRrYrLKZJt9KzF1jeEG2hs6oPw2AI4T73oFTAALaeTeDI4VC/O/FxKO9biu0nwSKgNCdLKJgBSD11rMhZ9lKxArQqGo6pEND6gB1bvpTZ+ImhJ+OntgaQvuExu0WW75NaCtgqopyVj9buv/CaMPiSBjebiJymhkrFCz var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 370 (Div. 2)(前三题)]]></title>
    <url>%2F%E8%A1%A5%E9%A2%980007%2F</url>
    <content type="text"><![CDATA[瞎扯淡整valine 1h后才去，看群里说要去cf打，vj又卡所以这次我直接在cf打的，打完再交vj的话我感觉不大好几分钟一个题，索性就直接不提交vj了最近整这些博客也是弄得有些飘手又生了需要找找手感 A. Memory and Crow(思维&amp;&amp;数学)胡乱分析实际上证明也可以，上来也可以看出来就是相邻两项的和加起来就可以了，注意一下最后一项单独输出即可 代码12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int num[666666];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;num[i]; for(int i=2;i&lt;=n;i++) cout&lt;&lt;num[i]+num[i-1]&lt;&lt;" "; cout&lt;&lt;num[n];&#125; B Memory and Trident(思维)胡乱分析上来就先wa的题。。。实际上这个题有个简单的方法。首先我们要注意到奇数个字符是一定不可以的，这个很容易就可以看出来然后我们还要发现有可能前面的步数会走回到过去的，这是我第一次wa发现的。。。那么最后的位置是距离原点有多少个x距离和y距离就有关于我们修改步数的个数了当然x和y看上去应该都是偶数实际上两个奇数相加也可能是偶数这里还需要思考一下，如果两个奇数相加会怎样，实际上还是把一个改成另一个即可了也就是说x变成y的步数，因为这里是随意更改的很随意的一种感觉最后我们可以得出结论答案就是(abs(x)+abs(y))/2这里确实不好说明情况，但是肯定是存在能搬回去的步子的还有一个codeforces的题跟这个任意修改的感觉挺像的B. Jumping Jack 代码12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); string a; int x=0,y=0; cin&gt;&gt;a; if(a.size()&amp;1) return cout&lt;&lt;-1,0; for(int i=0;i&lt;a.size();i++) &#123; if(a[i]=='U') x++; else if(a[i]=='D') x--; else if(a[i]=='R') y++; else if(a[i]=='L') y--; &#125; cout&lt;&lt;(abs(x)+abs(y))/2;&#125; Memory and De-Evolution(思维&amp;&amp;数学)胡乱分析首先我们要知道两边之和与第三边的关系，这就是这个题唯一的数学储备。然后我们看第三个样例发现我要是直接22-4不如22-7好，那么我们如何去寻找到这个x=7找到最优的这一步呢？接下去的最优步又怎么找呢？这里确实比较复杂，我是搞不出来。但是如果一想我们倒着来，也就是说我们不管你初始化边长如何，我们用短的去一直往上走最优解看什么时候三条边都走回到大于等于x即可，这样每次都是能保证是最优的所以可以保证能用最少的步数 代码1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int x,y,a,b,c,ans=0; cin&gt;&gt;x&gt;&gt;y; a=b=c=y; while(1) &#123; if(a&gt;=x&amp;&amp;b&gt;=x&amp;&amp;c&gt;=x) return cout&lt;&lt;ans,0; ans++; if(ans%3==0) a=b+c-1; else if(ans%3==1) b=a+c-1; else if(ans%3==2) c=a+b-1; &#125;&#125;]]></content>
      <categories>
        <category>补题</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[my goals]]></title>
    <url>%2F%E8%AE%B0%E5%BD%950006%2F</url>
    <content type="text"><![CDATA[马上就要开学了总结一下寒假里面的得与失预期：①Codeforces上到specialist(但是又掉下来了最近就保持了几天)②进行一些dp的学习(但是并没有学多少，学的好多东西也忘记了。。。)③学习python项目:(1)pygame编写了一个flappy bird之后就没有之后了，目前也不大记得了还要复习(2)tkinter中途放手，当时竞赛繁忙。(3)python oop学习完成50%也就会一些基本的重载运算符啥子的玩意，高深语法不会④减肥8斤，目前只减肥了4斤⑤恶补acm知识。。。。并没有学多少，还是混混的今后打算：①学习考研数学，先把数学学会了，目前感觉考研数学的恶心程度比高考轻一些②背四级词汇(背了两天最近弄博客又咕咕了)③继续减肥争取大一下学期能再减10斤④抽空学学前端⑤抽空学学python⑥继续抗acm]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 538 (Div. 2) (补题)]]></title>
    <url>%2F%E8%A1%A5%E9%A2%980005%2F</url>
    <content type="text"><![CDATA[感慨爬到青名的第一战，结果B题没有过system test又掉回到了1390+，这次越南出题组出的题还是比较有意思的 A Got Any Grapes?(模拟)分析根据题意我们可以进行模拟首先第一个人只吃绿色的，第二个人吃绿色和紫色的，第三个人通吃所以就可以得出我们先把绿色给第一个人吃，剩下的绿色和紫色给第二个人，最后剩下的给第三个人只要哪一步出现了问题，也就是说不够吃那么就是NO都可以就输出YES 代码1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,m,k,x,y,z; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;x&gt;&gt;y&gt;&gt;z; x-=n; if(x&lt;0) return cout&lt;&lt;"NO",0; int t1=x+y-m; if(t1&lt;0) return cout&lt;&lt;"NO",0; int t2=t1+z-k; if(t2&lt;0) return cout&lt;&lt;"NO",0; cout&lt;&lt;"YES";&#125; B Yet Another Array Partitioning Task(贪心+模拟)分析这个题操作很感人啊，当时我一看不就是把前mk个数加起来求和么，结果发现还有第二步找断点断点的寻找也是比较的难想，这里我分享一个简单的实现首先就是要找单位区间内的最大的理想值，我们需要把所有的前km项都要用上所以说我们要看看区间内是否符合当前m个要找的数操作方法就是把每个数先记下原来的坐标然后降序排列，定义一个新的数组用降序排列的顺序把原来的坐标定位到当前坐标也就是说要 1bk[pre[i].id]=i; 然后走一遍原先的坐标的顺序，就可以知道当前坐标是不是满足且合适的数了 代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;struct node&#123; long long sum,id;&#125;num[666666];bool cmp(node a,node b)&#123; return a.sum&gt;b.sum;&#125;int bk[666666];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); long long n,m,k,te=0,cnt=0,ans=0; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for(int i=1;i&lt;=n;i++) cin&gt;&gt;num[i].sum,num[i].id=i; sort(num+1,num+n+1,cmp); for(int i=1;i&lt;=m*k;i++) ans+=num[i].sum; for(int i=1;i&lt;=n;i++) bk[num[i].id]=i; cout&lt;&lt;ans&lt;&lt;"\n"; for(int i=1;i&lt;=n;i++) &#123; if(bk[i]&lt;=k*m) te++; if(te==m) &#123; cnt++; if(cnt&lt;k) cout&lt;&lt;i&lt;&lt;" "; te=0; &#125; &#125;&#125; C Trailing Loves (or L’oeufs?)(数论)分析很巧妙的一个题，用到数论的知识首先n!可以分解质因数并且b也能分解质因数所以我们可以用木桶原理看看这些阶乘里面最少能装几组质因数的次方首先我们要明白一个概念一个十进制有一个0代表这个十进制能整除10有两个0代表他能被10^2整除同样b进制也一样如果有一个0代表能被b整除有两个代表能被b^2整除且这是一个木桶原理也就是说找最小值就是能找到几个0然后就是分解质因数这里有一个十分巧妙的方法分解n!首先分解单个数的要寻找的质因数就是去寻找能被整除的次数也就是说如果找150有几个0就是循环2*5的分解质因数也就是 12345while(b%2==0)&#123; b/=2; cnt++;&#125; 然后求出最小值即可这样就能找到0的个数是1 1ans=min(ans1,ans2); 同样如果是n!那么我们会发现1-n总共有n个数所以说呢，我们需要进行一种特殊的方法同样以150为例不过这次是150!后有多少个0我们就需要寻找150能被2整除的多少次能被5整除的多少次也就是说 12345while(b/2)&#123; cnt+=b/2; b/=2;&#125; 最后取min即可最终我们结合两个步骤先质因数分解b然后接着分解a最后找floor(ai/bi)的最小值即可这里还需要注意有一个小小的优化那就是我们需要如果当前走的i*i&gt;b那么i=b因为一个数n的因子最大是sqrt(n)这里也是b在慢慢的缩小也是一种优化 代码123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); ll n,b; cin&gt;&gt;n&gt;&gt;b; ll ans=ll(1e18); for(ll i=2;i&lt;=b;i++) &#123; if(1LL*i*i&gt;b) i=b; ll cnt=0; while(b%i==0) &#123; b/=i; cnt++; &#125; if(cnt==0) continue; ll tmp=0,now=n; while(now/i) &#123; tmp+=now/i; now/=i; &#125; ans=min(ans,tmp/cnt); &#125; cout&lt;&lt;ans;&#125; D Flood Fill(DP)分析有二维的解法但是我太蒟蒻了，只会三维的。这个上来还容易re实际上就是定义两个：dp[l][r][0]代表最少需要多少步能够使l,r区域内都是num[l]颜色dp[l][r][1]代表最少需要多少步能够使l,r区域内都是num[r]颜色那么转移方程就是：dp[l-1][r][0]=min(dp[l-1][r][0],dp[l][r][t(当前的开关)]+左边的颜色与当前的颜色一样?1:0)第二个同理还有就是要注意这种枚举区间的方式 代码12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;int num[5001];int dp[5001][5001][2];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;num[i]; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) dp[i][j][0]=dp[i][j][1]=(i==j?0:999999); for(int r=1;r&lt;=n;r++) for(int l=r;l&gt;=1;l--) for(int t=0;t&lt;2;t++) &#123; int now=t==0?num[l]:num[r]; if(l&gt;1) dp[l-1][r][0]=min(dp[l-1][r][0],dp[l][r][t]+(now!=num[l-1])); if(r&lt;n) dp[l][r+1][1]=min(dp[l][r+1][1],dp[l][r][t]+(now!=num[r+1])); &#125; cout&lt;&lt;min(dp[1][n][0],dp[1][n][1]);&#125;]]></content>
      <categories>
        <category>补题</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[历时多天终于基本弄完了博客]]></title>
    <url>%2F%E8%AE%B0%E5%BD%950004%2F</url>
    <content type="text"><![CDATA[虽然还有很多不尽人意的地方，以后会慢慢的修改目前就先这样了！！！]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加密文档测试，密码为6个6]]></title>
    <url>%2F%E6%B5%8B%E8%AF%950003%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1/LvU43ptsQxvopvm4lDeK+jBmF6KBkskiDyWR2cYrinCQtW+mEntH2oA/VXNUtXl7yA4PShm6jcUwm9gNga7f2hrUr6lViIqlaNRr4MlNQVCTgniGYZQS/5M614HANcLNktg+PlpJIdasxjNSyUfUux95GFjnrPJpOvnHeFsAV6k0pQVJ1J48Qg/D0l7mnP7rFPBTMYLBiW4r89J9uV8WxdQfmkt16EzCYI2mXj8uaNniiDLKHCGEj//o+AXpqD21dBdiJI1Lx8aBCMGu7NwQz1hBaGtzocDBLBoqe8vTtxGhVWDMSYulQEgtO8e6GW4I2wP4yHtX+dQ== var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>test something</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三种语言样例测试]]></title>
    <url>%2F%E6%B5%8B%E8%AF%950002%2F</url>
    <content type="text"><![CDATA[测试一下三种语言的代码风格c语言版本 1234567#include &lt;stdio.h&gt;int main()&#123; int a,b; scanf("%d%d",&amp;a,&amp;b); printf("%d",a+b);&#125; c++版本 1234567891011#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int a,b; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;a+b;&#125; python 版本 123from math import *for i in range(1,11): print(2**i)]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>test something</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Anybody here?]]></title>
    <url>%2F%E8%AE%B0%E5%BD%950001%2F</url>
    <content type="text"><![CDATA[新博客正式启动！！！！多谢各位大佬的照顾与支持，新的一年里得更加的努力！！！老博客暂时不更新了SO FIGHTING!!!!]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
</search>
