<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[站内更新日志]]></title>
    <url>%2F%E8%AE%B0%E5%BD%950%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1+wpn6bRCnWvVH/cOUgapr0ZTa5kST7me5XPSankb9G9RKgmJF9eBj11R/zljzxa3QGuRCou4cxIavtrzDFw63SnE+iAjw5Fc7nk/1endhCTzT4VCzZdlkWgUC7+Ii8lRoIp1oz688jUS5YZlhDGq0Jq7trdatDOc9LE0WzKAGysm7gOO3czSLnnwn2vgWT5DKPjiUO0S6zL7Pu/IPjiUb2HyQpAV0Bzp0HEA68uZhjNLxbGhrCQQnzlBJPEe/4YU73II4FiQqR8fRhz5ZazLgPl0j5gdkiLQGlLlo80viRsboqoAYn+9gz7/bZUEUwEaZngQpVuId5umAw1yn93AIoai3YqPZNHcUlu9/kgaoB6VnGDi21YF0+VX09KcWSOG7SwGzOpjevPYTBK6OX+kMTMEPrR4j403EfSDjCoeuXxeEXA4XCo0M/21Ur/lcswTYtRz7P5IJmRlWWwTelNTNg4m7VjuWb4sWiZxiw9PPMNjLUJ0/9K3b284G8WKu88rc44DwDPZw5DPT3ovQ5z9ujYKqULgmI9c8Lxwnx96/ASi/NJTdg93BcShNV7ZsuYT67c7GuCK1UIUwf7h38OhciNxMYlzolPo7nqUJD6ei8vv5pqdVEsRH7D354nKUtAD7QGxmXY80g+MWYkKjQGme+rojDZ7OBkPHxUQAeucor2spgca4r4+NWQU2goCKeiZLqKj1NVvVqr7ThhshTKxXb/gOiVUtk6fbaVC1q2JpyAWcDkCOj/a+kVGW+VruD5t9/YE9BOK0GkpPVpJuCmGmtKwtRFwJQ6uNP8fjjwobWaG5Lk/ZT7hiiV4ik5BO/Ycid9qiwYY6y/jYdoeQAibdq2p51wrEb08EwltUoN5MjO/82kKyWl5D/cQw0Uqs/3UFq+MwTJVproryTOrV8tVQErF+7pbe1cIDpGc3gYRKqkRzkPLNWwpED var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 370 (Div. 2)(前三题)]]></title>
    <url>%2F%E8%A1%A5%E9%A2%980007%2F</url>
    <content type="text"><![CDATA[瞎扯淡整valine 1h后才去，看群里说要去cf打，vj又卡所以这次我直接在cf打的，打完再交vj的话我感觉不大好几分钟一个题，索性就直接不提交vj了最近整这些博客也是弄得有些飘手又生了需要找找手感 A. Memory and Crow(思维&amp;&amp;数学)胡乱分析实际上证明也可以，上来也可以看出来就是相邻两项的和加起来就可以了，注意一下最后一项单独输出即可 代码12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int num[666666];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;num[i]; for(int i=2;i&lt;=n;i++) cout&lt;&lt;num[i]+num[i-1]&lt;&lt;" "; cout&lt;&lt;num[n];&#125; B Memory and Trident(思维)胡乱分析上来就先wa的题。。。实际上这个题有个简单的方法。首先我们要注意到奇数个字符是一定不可以的，这个很容易就可以看出来然后我们还要发现有可能前面的步数会走回到过去的，这是我第一次wa发现的。。。那么最后的位置是距离原点有多少个x距离和y距离就有关于我们修改步数的个数了当然x和y看上去应该都是偶数实际上两个奇数相加也可能是偶数这里还需要思考一下，如果两个奇数相加会怎样，实际上还是把一个改成另一个即可了也就是说x变成y的步数，因为这里是随意更改的很随意的一种感觉最后我们可以得出结论答案就是(abs(x)+abs(y))/2这里确实不好说明情况，但是肯定是存在能搬回去的步子的还有一个codeforces的题跟这个任意修改的感觉挺像的B. Jumping Jack 代码12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); string a; int x=0,y=0; cin&gt;&gt;a; if(a.size()&amp;1) return cout&lt;&lt;-1,0; for(int i=0;i&lt;a.size();i++) &#123; if(a[i]=='U') x++; else if(a[i]=='D') x--; else if(a[i]=='R') y++; else if(a[i]=='L') y--; &#125; cout&lt;&lt;(abs(x)+abs(y))/2;&#125; Memory and De-Evolution(思维&amp;&amp;数学)胡乱分析首先我们要知道两边之和与第三边的关系，这就是这个题唯一的数学储备。然后我们看第三个样例发现我要是直接22-4不如22-7好，那么我们如何去寻找到这个x=7找到最优的这一步呢？接下去的最优步又怎么找呢？这里确实比较复杂，我是搞不出来。但是如果一想我们倒着来，也就是说我们不管你初始化边长如何，我们用短的去一直往上走最优解看什么时候三条边都走回到大于等于x即可，这样每次都是能保证是最优的所以可以保证能用最少的步数 代码1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int x,y,a,b,c,ans=0; cin&gt;&gt;x&gt;&gt;y; a=b=c=y; while(1) &#123; if(a&gt;=x&amp;&amp;b&gt;=x&amp;&amp;c&gt;=x) return cout&lt;&lt;ans,0; ans++; if(ans%3==0) a=b+c-1; else if(ans%3==1) b=a+c-1; else if(ans%3==2) c=a+b-1; &#125;&#125;]]></content>
      <categories>
        <category>补题</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[my goals]]></title>
    <url>%2F%E8%AE%B0%E5%BD%950006%2F</url>
    <content type="text"><![CDATA[马上就要开学了总结一下寒假里面的得与失预期：①Codeforces上到specialist(但是又掉下来了最近就保持了几天)②进行一些dp的学习(但是并没有学多少，学的好多东西也忘记了。。。)③学习python项目:(1)pygame编写了一个flappy bird之后就没有之后了，目前也不大记得了还要复习(2)tkinter中途放手，当时竞赛繁忙。(3)python oop学习完成50%也就会一些基本的重载运算符啥子的玩意，高深语法不会④减肥8斤，目前只减肥了4斤⑤恶补acm知识。。。。并没有学多少，还是混混的今后打算：①学习考研数学，先把数学学会了，目前感觉考研数学的恶心程度比高考轻一些②背四级词汇(背了两天最近弄博客又咕咕了)③继续减肥争取大一下学期能再减10斤④抽空学学前端⑤抽空学学python⑥继续抗acm]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 538 (Div. 2) (补题)]]></title>
    <url>%2F%E8%A1%A5%E9%A2%980005%2F</url>
    <content type="text"><![CDATA[感慨爬到青名的第一战，结果B题没有过system test又掉回到了1390+，这次越南出题组出的题还是比较有意思的 A Got Any Grapes?(模拟)分析根据题意我们可以进行模拟首先第一个人只吃绿色的，第二个人吃绿色和紫色的，第三个人通吃所以就可以得出我们先把绿色给第一个人吃，剩下的绿色和紫色给第二个人，最后剩下的给第三个人只要哪一步出现了问题，也就是说不够吃那么就是NO都可以就输出YES 代码1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,m,k,x,y,z; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;x&gt;&gt;y&gt;&gt;z; x-=n; if(x&lt;0) return cout&lt;&lt;"NO",0; int t1=x+y-m; if(t1&lt;0) return cout&lt;&lt;"NO",0; int t2=t1+z-k; if(t2&lt;0) return cout&lt;&lt;"NO",0; cout&lt;&lt;"YES";&#125; B Yet Another Array Partitioning Task(贪心+模拟)分析这个题操作很感人啊，当时我一看不就是把前mk个数加起来求和么，结果发现还有第二步找断点断点的寻找也是比较的难想，这里我分享一个简单的实现首先就是要找单位区间内的最大的理想值，我们需要把所有的前km项都要用上所以说我们要看看区间内是否符合当前m个要找的数操作方法就是把每个数先记下原来的坐标然后降序排列，定义一个新的数组用降序排列的顺序把原来的坐标定位到当前坐标也就是说要1bk[pre[i].id]=i; 然后走一遍原先的坐标的顺序，就可以知道当前坐标是不是满足且合适的数了 代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;struct node&#123; long long sum,id;&#125;num[666666];bool cmp(node a,node b)&#123; return a.sum&gt;b.sum;&#125;int bk[666666];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); long long n,m,k,te=0,cnt=0,ans=0; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for(int i=1;i&lt;=n;i++) cin&gt;&gt;num[i].sum,num[i].id=i; sort(num+1,num+n+1,cmp); for(int i=1;i&lt;=m*k;i++) ans+=num[i].sum; for(int i=1;i&lt;=n;i++) bk[num[i].id]=i; cout&lt;&lt;ans&lt;&lt;"\n"; for(int i=1;i&lt;=n;i++) &#123; if(bk[i]&lt;=k*m) te++; if(te==m) &#123; cnt++; if(cnt&lt;k) cout&lt;&lt;i&lt;&lt;" "; te=0; &#125; &#125;&#125; C Trailing Loves (or L’oeufs?)(数论)分析很巧妙的一个题，用到数论的知识首先n!可以分解质因数并且b也能分解质因数所以我们可以用木桶原理看看这些阶乘里面最少能装几组质因数的次方首先我们要明白一个概念一个十进制有一个0代表这个十进制能整除10有两个0代表他能被10^2整除同样b进制也一样如果有一个0代表能被b整除有两个代表能被b^2整除且这是一个木桶原理也就是说找最小值就是能找到几个0然后就是分解质因数这里有一个十分巧妙的方法分解n!首先分解单个数的要寻找的质因数就是去寻找能被整除的次数也就是说如果找150有几个0就是循环2*5的分解质因数也就是12345while(b%2==0)&#123; b/=2; cnt++;&#125; 然后求出最小值即可这样就能找到0的个数是11ans=min(ans1,ans2); 同样如果是n!那么我们会发现1-n总共有n个数所以说呢，我们需要进行一种特殊的方法同样以150为例不过这次是150!后有多少个0我们就需要寻找150能被2整除的多少次能被5整除的多少次也就是说12345while(b/2)&#123; cnt+=b/2; b/=2;&#125; 最后取min即可最终我们结合两个步骤先质因数分解b然后接着分解a最后找floor(ai/bi)的最小值即可这里还需要注意有一个小小的优化那就是我们需要如果当前走的i*i&gt;b那么i=b因为一个数n的因子最大是sqrt(n)这里也是b在慢慢的缩小也是一种优化 代码123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); ll n,b; cin&gt;&gt;n&gt;&gt;b; ll ans=ll(1e18); for(ll i=2;i&lt;=b;i++) &#123; if(1LL*i*i&gt;b) i=b; ll cnt=0; while(b%i==0) &#123; b/=i; cnt++; &#125; if(cnt==0) continue; ll tmp=0,now=n; while(now/i) &#123; tmp+=now/i; now/=i; &#125; ans=min(ans,tmp/cnt); &#125; cout&lt;&lt;ans;&#125; D Flood Fill(DP)分析有二维的解法但是我太蒟蒻了，只会三维的。这个上来还容易re实际上就是定义两个：dp[l][r][0]代表最少需要多少步能够使l,r区域内都是num[l]颜色dp[l][r][1]代表最少需要多少步能够使l,r区域内都是num[r]颜色那么转移方程就是：dp[l-1][r][0]=min(dp[l-1][r][0],dp[l][r][t(当前的开关)]+左边的颜色与当前的颜色一样?1:0)第二个同理还有就是要注意这种枚举区间的方式 代码12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;int num[5001];int dp[5001][5001][2];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;num[i]; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) dp[i][j][0]=dp[i][j][1]=(i==j?0:999999); for(int r=1;r&lt;=n;r++) for(int l=r;l&gt;=1;l--) for(int t=0;t&lt;2;t++) &#123; int now=t==0?num[l]:num[r]; if(l&gt;1) dp[l-1][r][0]=min(dp[l-1][r][0],dp[l][r][t]+(now!=num[l-1])); if(r&lt;n) dp[l][r+1][1]=min(dp[l][r+1][1],dp[l][r][t]+(now!=num[r+1])); &#125; cout&lt;&lt;min(dp[1][n][0],dp[1][n][1]);&#125;]]></content>
      <categories>
        <category>补题</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[历时多天终于基本弄完了博客]]></title>
    <url>%2F%E8%AE%B0%E5%BD%950004%2F</url>
    <content type="text"><![CDATA[虽然还有很多不尽人意的地方，以后会慢慢的修改目前就先这样了！！！]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加密文档测试，密码为6个6]]></title>
    <url>%2F%E6%B5%8B%E8%AF%950003%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1+pJVyLk2T8VJ+x+QCpbwdNSlbKeWBVKYfW9d+w5KxJT/aGUVY46qyrIdf0GN30G9/mWS4ltJY4iEXTVGouWMyfYPu5CZfR1Nl/taQ3ekOmfjEZaYOIwlukW2DLbcf9c8+ZcVtKsU77ZG0AWJ+IZU/cuX/5TMxtIUGtfuVC7dE4QOX70kTnhUiAdw0Pcm5+oPUlMcSRlVU6E6A1IN+Vhraqux2SPkTUVLML9vC9sgO8p4nfVmYrCEQT1MKhbAj7jZIrFj3A2cf2wsxdDto9o3q0BS8DUX5m4gRn1+XnRUA1EG3j4BpnO8MRTorQGiSzNrPf8Itl82iFXw== var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>test something</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三种语言样例测试]]></title>
    <url>%2F%E6%B5%8B%E8%AF%950002%2F</url>
    <content type="text"><![CDATA[测试一下三种语言的代码风格c语言版本1234567#include &lt;stdio.h&gt;int main()&#123; int a,b; scanf("%d%d",&amp;a,&amp;b); printf("%d",a+b);&#125; c++版本1234567891011#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int a,b; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;a+b;&#125; python 版本123from math import *for i in range(1,11): print(2**i)]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>test something</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Anybody here?]]></title>
    <url>%2F%E8%AE%B0%E5%BD%950001%2F</url>
    <content type="text"><![CDATA[新博客正式启动！！！！多谢各位大佬的照顾与支持，新的一年里得更加的努力！！！老博客暂时不更新了SO FIGHTING!!!!]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
</search>
