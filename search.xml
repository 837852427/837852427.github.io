<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[bfs判断转弯次数]]></title>
    <url>%2F%E7%AE%97%E6%B3%9511%2F</url>
    <content type="text"><![CDATA[bfs判断转弯次数也就是顾名思义我们如何来应对需要至少转弯多少次或者计算总共转弯多少次的题目 胡乱分析例题 P1649 [USACO07OCT]障碍路线Obstacle Course算法核心在于对每个能到达的部分进行枚举然后进行一波更新123456789101112131415for(int i=0;i&lt;4;i++)&#123; int xx=p.x+dx[i]; int yy=p.y+dy[i]; while(check(xx,yy)) &#123; if(step[xx][yy]&gt;step[p.x][p.y]+1) &#123; step[xx][yy]=step[p.x][p.y]+1; q.push((node)&#123;xx,yy&#125;); &#125; xx+=dx[i]; yy+=dy[i]; &#125;&#125; 还需要注意除了开始节点设置为-1其他节点初始化都为inf(也就是一个极大值) 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;char mp[666][666];int sx,sy,ex,ey,f,step[666][666];struct node&#123; int x,y;&#125;;int dx[]=&#123;-1,1,0,0&#125;;int dy[]=&#123;0,0,-1,1&#125;;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) &#123; cin&gt;&gt;mp[i][j]; if(mp[i][j]=='A') sx=i,sy=j; else if(mp[i][j]=='B') ex=i,ey=j; step[i][j]=99999; &#125; step[sx][sy]=-1; queue&lt;node&gt; q; q.push((node)&#123;sx,sy&#125;); while(q.size()) &#123; node p=q.front(); q.pop(); if(p.x==ex&amp;&amp;p.y==ey) &#123; f=1; break; &#125; for(int i=0;i&lt;4;i++) &#123; int xx=p.x+dx[i]; int yy=p.y+dy[i]; while(xx&gt;=1&amp;&amp;yy&gt;=1&amp;&amp;xx&lt;=n&amp;&amp;yy&lt;=n&amp;&amp;mp[xx][yy]!='x') &#123; if(step[xx][yy]&gt;step[p.x][p.y]+1) &#123; step[xx][yy]=step[p.x][p.y]+1; q.push((node)&#123;xx,yy&#125;); &#125; xx+=dx[i]; yy+=dy[i]; &#125; &#125; &#125; cout&lt;&lt;(f?step[ex][ey]:-1);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html学习(1)]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF10%2F</url>
    <content type="text"><![CDATA[本文我准备都用html进行书写 实际上也没有多少需要书写的内容直接放上这部分的代码即可了 这次也是基本的学习完了html的一些基础操作 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110&lt;html&gt; &lt;head&gt; &lt;title&gt;my first html&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;this is h1&lt;/h1&gt; &lt;p&gt;this is p&lt;/p&gt; &lt;p&gt;&lt;b&gt;粗体字&lt;/b&gt;&lt;/p&gt; &lt;p&gt;&lt;i&gt;italic&lt;/i&gt;&lt;/p&gt; &lt;p&gt;e=mc&lt;sup&gt;2&lt;/sup&gt;&lt;/p&gt; &lt;p&gt;co&lt;sub&gt;2&lt;/sub&gt;&lt;/p&gt; &lt;p&gt;换行符&lt;br /&gt;换行符&lt;/p&gt; &lt;p&gt;插入横线&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;横线下面&lt;/p&gt; &lt;p&gt;&lt;strong&gt;strong&lt;/strong&gt; &lt;em&gt;em&lt;/em&gt; &lt;/p&gt; &lt;blockquote cite="http://www.baidu.com"&gt; &lt;p&gt;前往百度&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;&lt;cite&gt;cite&lt;/cite&gt;&lt;/p&gt; &lt;p&gt;&lt;dfn&gt;dfn&lt;/dfn&gt;&lt;/p&gt; &lt;p&gt;&lt;ins&gt;ins&lt;/ins&gt;&lt;del&gt;del&lt;/del&gt;&lt;/p&gt; &lt;p&gt;&lt;s&gt;s&lt;/s&gt;&lt;/p&gt; &lt;ol&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ol&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;dl&gt; &lt;dt&gt;1&lt;/dt&gt; &lt;dd&gt;1的内容&lt;/dd&gt; &lt;dt&gt;2&lt;/dt&gt; &lt;dd&gt;2的内容&lt;/dd&gt; &lt;/dl&gt; &lt;a href="https://www.baidu.com"&gt;baidu&lt;/a&gt; &lt;br /&gt; &lt;a href="https://www.baidu.com" target="_blank"&gt;baidu&lt;/a&gt; &lt;br /&gt; &lt;figure&gt; &lt;img src="https://i.loli.net/2019/02/14/5c64fb8ce8b64.jpeg" alt="一张图片" /&gt; &lt;br /&gt; &lt;figcaption&gt; 图片的描述 &lt;/figcaption&gt; &lt;/figure&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;15&lt;/td&gt; &lt;td&gt;15&lt;/td&gt; &lt;td&gt;30&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;15&lt;/td&gt; &lt;td&gt;15&lt;/td&gt; &lt;td&gt;30&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;15&lt;/td&gt; &lt;td&gt;15&lt;/td&gt; &lt;td&gt;30&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt; &lt;th scope="col"&gt;c1&lt;/th&gt; &lt;th scope="col"&gt;c2&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th scope="row"&gt;r1&lt;/th&gt; &lt;td&gt;120&lt;/td&gt; &lt;td&gt;130&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th scope="row"&gt;r2&lt;/th&gt; &lt;td&gt;$600&lt;/td&gt; &lt;td&gt;$675&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;form class="" action="index.html" method="post"&gt; &lt;p&gt; username: &lt;input type="text" name="username" size="15"&gt; &lt;/p&gt; &lt;/form&gt; &lt;form class="" action="index.html" method="post"&gt; &lt;p&gt;密码 &lt;input type="password" name="密码" value="" size="15"&gt; &lt;/p&gt; &lt;/form&gt; &lt;form class="" action="index.html" method="post"&gt; &lt;p&gt;选择一下 &lt;br /&gt; &lt;input type="radio" name="genre" value="rock" checked="checked" /&gt; rock &lt;input type="radio" name="genre" value="pop" /&gt; pop &lt;input type="radio" name="genre" value="jazz" /&gt; jazz &lt;/p&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[背包变形:过程型背包]]></title>
    <url>%2F%E7%AE%97%E6%B3%959%2F</url>
    <content type="text"><![CDATA[过程型背包简单的感觉就是我要记录下是否回到这种情况，也就是说要记录一个最大到达的可能值或者是一个最小到达的可能值 #例1 P1877 [HAOI2012]音量调节 胡乱分析上来bfs得60分。。。dp的思路就是我看看我能最终到达的最大音量是多少，每一步都有两种可能性，也就是我要加音量或者我要减当前的音量所以我们思路就是:for i-&gt;[1,n] (这里表示我们总共弹奏的歌曲数) for j-&gt;[0,maxn] (这里表示我们j从0枚举到最大值) if dp[i-1][j] dp[i][j+num[i]]=dp[i][j-num[i]]=1 (这里表示我们如果上一个音量是合法的那么我们把他所能表示出来的音量也标记为合法的) 代码123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;int num[6666],dp[6666][6666];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,begin,maxn; cin&gt;&gt;n&gt;&gt;begin&gt;&gt;maxn; for(int i=1;i&lt;=n;i++) cin&gt;&gt;num[i]; dp[0][begin]=1; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;=maxn;j++) &#123; if(dp[i-1][j]) dp[i][j+num[i]]=dp[i][j-num[i]]=1; &#125; for(int i=maxn;i&gt;=0;i--) if(dp[n][i]) return cout&lt;&lt;i,0; cout&lt;&lt;-1;&#125; 例2 待补充]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[完全背包变形(1) 取数问题]]></title>
    <url>%2F%E7%AE%97%E6%B3%958%2F</url>
    <content type="text"><![CDATA[朴素的完全背包就是总容量一定物品无限能放多少东西，这里记录一下最近遇到的变形取数问题首先需要说明一下板子的基本情况:一个数分解为几个数的和的形式有多少种方案数或者最多/最少能分解为多少位? 例1 P1832 A+B Problem（再升级）胡乱分析看着像是要搜索但是我感觉搜索应该得tle，这个就是比较朴素的取数问题变形了首先我们定义v是背包容量,n是[2,n]内有多少个质数这样把质数放进背包的板子就成型了注意初始值设定dp[0]=1表示什么都不装是有1个的(即这个数本身也算一种) 代码1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;int isp(int n)&#123; for(int i=2;i*i&lt;=n;i++) if(n%i==0) return 0; return 1;&#125;long long dp[6666],bk[6666],mk[6666],v[6666],p=1;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,sum=0; dp[0]=1; for(int i=2;i&lt;=1000;i++) if(isp(i)) bk[i]=1; for(int i=2;i&lt;=1000;i++) &#123; if(bk[i]) &#123; v[p++]=i; sum++; &#125; mk[i]=sum; &#125; cin&gt;&gt;n; for(int i=1;i&lt;=mk[n];i++) for(int j=v[i];j&lt;=n;j++) dp[j]+=dp[j-v[i]]; cout&lt;&lt;dp[n];&#125; 例2 P1679 神奇的四次方数胡乱分析跟例一一模一样注意这里就是把素数换成了四方数把方案数换成了最少的个数同样套板子即可v是这个数的大小，n是[1,n]内有几个四方数这里dp[0]=0数本身不算分解的一部分 代码123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;double num[66666],mk[666666];int sum,p=1,dp[666666];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); memset(dp,0x7f,sizeof(dp)); dp[0]=0; for(double i=1;;i++) if(pow(i,4)&lt;=1e5) num[p++]=pow(i,4); else break; p=1; for(int i=1;i&lt;=int(1e5);i++) &#123; if(i==num[p]) &#123; p++; sum++; &#125; mk[i]=sum; &#125; int n; cin&gt;&gt;n; for(int i=1;i&lt;=mk[n];i++) for(int j=num[i];j&lt;=n;j++) dp[j]=min(dp[j],dp[int(j-num[i])]+1); cout&lt;&lt;dp[n];&#125; 例3 自然数无序拆分题目描述(摘自中石油oj 10255)美羊羊给喜羊羊和沸羊羊出了一道难题，说谁能先做出来，我就奖励给他我自己做的一样礼物。沸羊羊这下可乐了，于是马上答应立刻做出来，喜羊羊见状，当然也不甘示弱，向沸羊羊发起了挑战。可是这道题目有一些难度，喜羊羊做了一会儿，见沸羊羊也十分头疼，于是就来请教你。题目是这样的：把自然数Ｎ（N&lt;＝100）分解为若干个自然数之和，求出有几种情况。如N＝5时，有7种情况5=1+1+1+1+15=1+1+1+25=1+1+35=1+2+25=1+45=2+35=5怎么样？你要加油帮助喜羊羊哦！ 胡乱分析还是典型的问题，这个更简单了。。。实际上就是套板子即可v是n个数n是n个数注意dp[0]=1代表数本身是算一个的 代码12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int dp[666];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; cin&gt;&gt;n; dp[0]=1; for(int i=1;i&lt;=n;i++) for(int j=i;j&lt;=n;j++) dp[j]+=dp[j-i]; cout&lt;&lt;dp[n];&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[站内更新日志]]></title>
    <url>%2F%E8%AE%B0%E5%BD%950%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1+5hcPpWeZIe9HtU+S0gyUD1FRfeQIzv+L3U+aSU5P0Y8gLoWbOiUd8VMQyStR4bo/+2S4OMf6aW7BW8EOWemnW6tklrxRWSzhuAf63gvfsiqViLwIXSMAHbFRllMnrIGoSEhkPf0AHy0OHJl2VEj40B0yfpleTX+tymjFgeaARLgpiTESG5YTGCTnuZPELuDK6OouCoNGotfkvCCo6dxGBMMiOMWKfiehuoHIZQj2Y5ujtYQAcM2cd/dztwByADDQmYlMZVUoKr8UTcQaNplQNpd52h/fpeYaDssu4ECxhOHk1Ys1JLJVwXbEz3ksLEKHX9oLr0XMOwF/0AfUmRZ5Y4V6a+g+oFSx6+uVotnk/MdEjJWQfpEz0aYIhTw/kEi6L7NmtlRdGFBjh/fZmXFtIHVu+IJFs7/7nh5tdaXDuZznJk5dr7tXGioaEhYx3Rj9OR50TuzvXjgSGvDZKiUATDsGVV4sOB7UNNSJnaZYHzByPBhuUM/ZeHCk84GsEjBtrGlhXr55Hd4FJuouY488Y/MdwYEXh2GF/a8e+QQZYAqqtbEdwFkidEjclulYYYWNjlAhc95aVarbv9JrtZ42d4zPMszTr5GqwjpUXESShhcCQmqoKFVoVQ7rb2DEP0dGSvFDvpcYOoFh3T93TsApFHfPsnloY9uhNO0gcrLI1KZOz33IcHa3NjgLIEtir95XPEiIQUpLW7yqxogJ8uF2toRDdb084KXVCAb2E/xZaPUKL7rKpRtaDfXIHYcYO/0ZoKEDJPU2fnd9MNB9q30d7rhJLjSpP0pC9ajU3m1Tk0L13bkoP36pQi0mEWq/0KdRB5dPJ9RJ1VzcJ09IqgwzxjiJnVjxb5YEnoIVEX6MsLnctOwq+7EEJl8zeJQKUlb+uSBRron1C+9auurGJ2re5nIHcDQRW+jSqjY/K7VR/ObkhTe8SK5T2 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 370 (Div. 2)(前三题)]]></title>
    <url>%2F%E8%A1%A5%E9%A2%980007%2F</url>
    <content type="text"><![CDATA[瞎扯淡整valine 1h后才去，看群里说要去cf打，vj又卡所以这次我直接在cf打的，打完再交vj的话我感觉不大好几分钟一个题，索性就直接不提交vj了最近整这些博客也是弄得有些飘手又生了需要找找手感 A. Memory and Crow(思维&amp;&amp;数学)胡乱分析实际上证明也可以，上来也可以看出来就是相邻两项的和加起来就可以了，注意一下最后一项单独输出即可 代码12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int num[666666];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;num[i]; for(int i=2;i&lt;=n;i++) cout&lt;&lt;num[i]+num[i-1]&lt;&lt;" "; cout&lt;&lt;num[n];&#125; B Memory and Trident(思维)胡乱分析上来就先wa的题。。。实际上这个题有个简单的方法。首先我们要注意到奇数个字符是一定不可以的，这个很容易就可以看出来然后我们还要发现有可能前面的步数会走回到过去的，这是我第一次wa发现的。。。那么最后的位置是距离原点有多少个x距离和y距离就有关于我们修改步数的个数了当然x和y看上去应该都是偶数实际上两个奇数相加也可能是偶数这里还需要思考一下，如果两个奇数相加会怎样，实际上还是把一个改成另一个即可了也就是说x变成y的步数，因为这里是随意更改的很随意的一种感觉最后我们可以得出结论答案就是(abs(x)+abs(y))/2这里确实不好说明情况，但是肯定是存在能搬回去的步子的还有一个codeforces的题跟这个任意修改的感觉挺像的B. Jumping Jack 代码12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); string a; int x=0,y=0; cin&gt;&gt;a; if(a.size()&amp;1) return cout&lt;&lt;-1,0; for(int i=0;i&lt;a.size();i++) &#123; if(a[i]=='U') x++; else if(a[i]=='D') x--; else if(a[i]=='R') y++; else if(a[i]=='L') y--; &#125; cout&lt;&lt;(abs(x)+abs(y))/2;&#125; Memory and De-Evolution(思维&amp;&amp;数学)胡乱分析首先我们要知道两边之和与第三边的关系，这就是这个题唯一的数学储备。然后我们看第三个样例发现我要是直接22-4不如22-7好，那么我们如何去寻找到这个x=7找到最优的这一步呢？接下去的最优步又怎么找呢？这里确实比较复杂，我是搞不出来。但是如果一想我们倒着来，也就是说我们不管你初始化边长如何，我们用短的去一直往上走最优解看什么时候三条边都走回到大于等于x即可，这样每次都是能保证是最优的所以可以保证能用最少的步数 代码1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int x,y,a,b,c,ans=0; cin&gt;&gt;x&gt;&gt;y; a=b=c=y; while(1) &#123; if(a&gt;=x&amp;&amp;b&gt;=x&amp;&amp;c&gt;=x) return cout&lt;&lt;ans,0; ans++; if(ans%3==0) a=b+c-1; else if(ans%3==1) b=a+c-1; else if(ans%3==2) c=a+b-1; &#125;&#125;]]></content>
      <categories>
        <category>补题</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[my goals]]></title>
    <url>%2F%E8%AE%B0%E5%BD%950006%2F</url>
    <content type="text"><![CDATA[马上就要开学了总结一下寒假里面的得与失预期：①Codeforces上到specialist(但是又掉下来了最近就保持了几天)②进行一些dp的学习(但是并没有学多少，学的好多东西也忘记了。。。)③学习python项目:(1)pygame编写了一个flappy bird之后就没有之后了，目前也不大记得了还要复习(2)tkinter中途放手，当时竞赛繁忙。(3)python oop学习完成50%也就会一些基本的重载运算符啥子的玩意，高深语法不会④减肥8斤，目前只减肥了4斤⑤恶补acm知识。。。。并没有学多少，还是混混的今后打算：①学习考研数学，先把数学学会了，目前感觉考研数学的恶心程度比高考轻一些②背四级词汇(背了两天最近弄博客又咕咕了)③继续减肥争取大一下学期能再减10斤④抽空学学前端⑤抽空学学python⑥继续抗acm]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 538 (Div. 2) (补题)]]></title>
    <url>%2F%E8%A1%A5%E9%A2%980005%2F</url>
    <content type="text"><![CDATA[感慨爬到青名的第一战，结果B题没有过system test又掉回到了1390+，这次越南出题组出的题还是比较有意思的 A Got Any Grapes?(模拟)分析根据题意我们可以进行模拟首先第一个人只吃绿色的，第二个人吃绿色和紫色的，第三个人通吃所以就可以得出我们先把绿色给第一个人吃，剩下的绿色和紫色给第二个人，最后剩下的给第三个人只要哪一步出现了问题，也就是说不够吃那么就是NO都可以就输出YES 代码1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,m,k,x,y,z; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;x&gt;&gt;y&gt;&gt;z; x-=n; if(x&lt;0) return cout&lt;&lt;"NO",0; int t1=x+y-m; if(t1&lt;0) return cout&lt;&lt;"NO",0; int t2=t1+z-k; if(t2&lt;0) return cout&lt;&lt;"NO",0; cout&lt;&lt;"YES";&#125; B Yet Another Array Partitioning Task(贪心+模拟)分析这个题操作很感人啊，当时我一看不就是把前mk个数加起来求和么，结果发现还有第二步找断点断点的寻找也是比较的难想，这里我分享一个简单的实现首先就是要找单位区间内的最大的理想值，我们需要把所有的前km项都要用上所以说我们要看看区间内是否符合当前m个要找的数操作方法就是把每个数先记下原来的坐标然后降序排列，定义一个新的数组用降序排列的顺序把原来的坐标定位到当前坐标也就是说要1bk[pre[i].id]=i; 然后走一遍原先的坐标的顺序，就可以知道当前坐标是不是满足且合适的数了 代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;struct node&#123; long long sum,id;&#125;num[666666];bool cmp(node a,node b)&#123; return a.sum&gt;b.sum;&#125;int bk[666666];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); long long n,m,k,te=0,cnt=0,ans=0; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for(int i=1;i&lt;=n;i++) cin&gt;&gt;num[i].sum,num[i].id=i; sort(num+1,num+n+1,cmp); for(int i=1;i&lt;=m*k;i++) ans+=num[i].sum; for(int i=1;i&lt;=n;i++) bk[num[i].id]=i; cout&lt;&lt;ans&lt;&lt;"\n"; for(int i=1;i&lt;=n;i++) &#123; if(bk[i]&lt;=k*m) te++; if(te==m) &#123; cnt++; if(cnt&lt;k) cout&lt;&lt;i&lt;&lt;" "; te=0; &#125; &#125;&#125; C Trailing Loves (or L’oeufs?)(数论)分析很巧妙的一个题，用到数论的知识首先n!可以分解质因数并且b也能分解质因数所以我们可以用木桶原理看看这些阶乘里面最少能装几组质因数的次方首先我们要明白一个概念一个十进制有一个0代表这个十进制能整除10有两个0代表他能被10^2整除同样b进制也一样如果有一个0代表能被b整除有两个代表能被b^2整除且这是一个木桶原理也就是说找最小值就是能找到几个0然后就是分解质因数这里有一个十分巧妙的方法分解n!首先分解单个数的要寻找的质因数就是去寻找能被整除的次数也就是说如果找150有几个0就是循环2*5的分解质因数也就是12345while(b%2==0)&#123; b/=2; cnt++;&#125; 然后求出最小值即可这样就能找到0的个数是11ans=min(ans1,ans2); 同样如果是n!那么我们会发现1-n总共有n个数所以说呢，我们需要进行一种特殊的方法同样以150为例不过这次是150!后有多少个0我们就需要寻找150能被2整除的多少次能被5整除的多少次也就是说12345while(b/2)&#123; cnt+=b/2; b/=2;&#125; 最后取min即可最终我们结合两个步骤先质因数分解b然后接着分解a最后找floor(ai/bi)的最小值即可这里还需要注意有一个小小的优化那就是我们需要如果当前走的i*i&gt;b那么i=b因为一个数n的因子最大是sqrt(n)这里也是b在慢慢的缩小也是一种优化 代码123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); ll n,b; cin&gt;&gt;n&gt;&gt;b; ll ans=ll(1e18); for(ll i=2;i&lt;=b;i++) &#123; if(1LL*i*i&gt;b) i=b; ll cnt=0; while(b%i==0) &#123; b/=i; cnt++; &#125; if(cnt==0) continue; ll tmp=0,now=n; while(now/i) &#123; tmp+=now/i; now/=i; &#125; ans=min(ans,tmp/cnt); &#125; cout&lt;&lt;ans;&#125; D Flood Fill(DP)分析有二维的解法但是我太蒟蒻了，只会三维的。这个上来还容易re实际上就是定义两个：dp[l][r][0]代表最少需要多少步能够使l,r区域内都是num[l]颜色dp[l][r][1]代表最少需要多少步能够使l,r区域内都是num[r]颜色那么转移方程就是：dp[l-1][r][0]=min(dp[l-1][r][0],dp[l][r][t(当前的开关)]+左边的颜色与当前的颜色一样?1:0)第二个同理还有就是要注意这种枚举区间的方式 代码12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;int num[5001];int dp[5001][5001][2];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;num[i]; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) dp[i][j][0]=dp[i][j][1]=(i==j?0:999999); for(int r=1;r&lt;=n;r++) for(int l=r;l&gt;=1;l--) for(int t=0;t&lt;2;t++) &#123; int now=t==0?num[l]:num[r]; if(l&gt;1) dp[l-1][r][0]=min(dp[l-1][r][0],dp[l][r][t]+(now!=num[l-1])); if(r&lt;n) dp[l][r+1][1]=min(dp[l][r+1][1],dp[l][r][t]+(now!=num[r+1])); &#125; cout&lt;&lt;min(dp[1][n][0],dp[1][n][1]);&#125;]]></content>
      <categories>
        <category>补题</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[历时多天终于基本弄完了博客]]></title>
    <url>%2F%E8%AE%B0%E5%BD%950004%2F</url>
    <content type="text"><![CDATA[虽然还有很多不尽人意的地方，以后会慢慢的修改目前就先这样了！！！]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加密文档测试，密码为6个6]]></title>
    <url>%2F%E6%B5%8B%E8%AF%950003%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX19iXCryqEazgIKhA8AoIvZewmDEiII5O+zAcb1hFxSeYK+VexToStvNJ1kddQZ03B6+Lm/vsKLRXyjpPjyLz4mpH94+P1pVdNpn5VQtWqeE532eDhoYXDfpqIgq6zfUWkcaeO9C2KpaxLszFyh7oEYj81PvWnjcoPnmdLTeKtNu0PLyINOU/hf0gpCEu83GYU+sI1O3p1qX6vWScEmBGCJBDSOwYjp7SXMrWMZqngfWDtqSRlb4dNC5hrb56+0DJ0jkjyyMU2phTyEO8Gk53Q7KcRRKuR/82+t6+0+zUNogRXJYdaZzWsYsWgv4pNoFyjbfp3N7QHJOuw== var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>test something</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三种语言样例测试]]></title>
    <url>%2F%E6%B5%8B%E8%AF%950002%2F</url>
    <content type="text"><![CDATA[测试一下三种语言的代码风格c语言版本1234567#include &lt;stdio.h&gt;int main()&#123; int a,b; scanf("%d%d",&amp;a,&amp;b); printf("%d",a+b);&#125; c++版本1234567891011#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int a,b; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;a+b;&#125; python 版本123from math import *for i in range(1,11): print(2**i)]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>test something</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Anybody here?]]></title>
    <url>%2F%E8%AE%B0%E5%BD%950001%2F</url>
    <content type="text"><![CDATA[新博客正式启动！！！！多谢各位大佬的照顾与支持，新的一年里得更加的努力！！！老博客暂时不更新了SO FIGHTING!!!!]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
</search>
